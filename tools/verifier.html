<!DOCTYPE html>
<html>
<head>
    <title>Cyborg ZOSCII Encoder/Verifier</title>
    <style>
        html, body {
            height: 100vh;
            overflow: hidden;
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }
        .container {
            height: 100vh;
            max-width: 100%;
            overflow: hidden;
            padding: 20px;
            box-sizing: border-box;
        }
        .text-center { text-align: center; }
        .mb-4 { margin-bottom: 1.5rem; }
        .mt-4 { margin-top: 1.5rem; }
        .mt-3 { margin-top: 1rem; }
        .mt-2 { margin-top: 0.5rem; }
        .mb-3 { margin-bottom: 1rem; }
        .me-2 { margin-right: 0.5rem; }
        .text-end { text-align: right; }
        .text-muted { color: #6c757d; }
        
        /* Tab styling */
        .nav-tabs {
            list-style: none;
            padding: 0;
            margin: 0 0 20px 0;
            border-bottom: 1px solid #dee2e6;
            display: flex;
        }
        .nav-item {
            margin-right: 5px;
        }
        .nav-link {
            display: block;
            padding: 8px 16px;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-bottom: none;
            cursor: pointer;
            text-decoration: none;
            color: #495057;
        }
        .nav-link.active {
            background-color: white;
            border-bottom: 1px solid white;
        }
        .nav-link:hover {
            background-color: #e9ecef;
        }
        
        /* Tab content */
        .tab-content {
            height: calc(100vh - 170px);
            overflow: hidden;
        }
        .tab-pane {
            height: 100%;
            overflow: hidden;
            display: none;
        }
        .tab-pane.active {
            display: block;
        }
        
        .encoder-content {
            height: calc(100vh - 230px);
        }
        
        /* Drop zones */
        .drop-zone {
            border: 3px dashed #ccc;
            border-radius: 10px;
            text-align: center;
            font-size: 18px;
            cursor: pointer;
            color: #ccc;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }
        .drop-zone.dragover {
            border-color: #007bff;
            color: #007bff;
            background-color: #f8f9fa;
        }
        .drop-zone.has-file {
            border-color: #28a745;
            color: #28a745;
            background-color: #d4edda;
        }
        #romDropZone {
            height: calc((100vh - 300px) * 0.25);
        }
		#romDropZone:hover {
			border-color: #007bff;
			color: #007bff;
			background-color: #f8f9fa;
		}
        #zosciiDropZone {
            height: calc((100vh - 400px) * 0.3);
        }
		#zosciiDropZone:hover {
			border-color: #007bff;
			color: #007bff;
			background-color: #f8f9fa;
		}
        
        /* Form elements */
        #textInput, .form-control {
            width: 100%;
            height: calc((100vh - 450px) * 0.4);
            padding: 8px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            resize: none;
            box-sizing: border-box;
            font-family: monospace;
        }
        .form-select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ced4da;
            border-radius: 4px;
        }
        .form-label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        /* Buttons */
        .btn {
            padding: 8px 16px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .btn-primary {
            background-color: #007bff;
            color: white;
        }
        .btn-success {
            background-color: #28a745;
            color: white;
        }
        .btn-secondary {
            background-color: #6c757d;
            color: white;
        }
        .btn:disabled {
            background-color: #6c757d;
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn:hover:not(:disabled) {
            opacity: 0.9;
        }
        
        /* Tables */
        .table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        .table td, .table th {
            padding: 8px;
            border-bottom: 1px solid #dee2e6;
            text-align: left;
        }
        .table th {
            background-color: #f8f9fa;
            font-weight: bold;
        }
        .analysis-table {
            font-size: 12px;
        }
        
        /* Alerts */
        .alert {
            padding: 15px;
            border-radius: 4px;
            margin: 10px 0;
        }
        .alert-success {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }
        
        /* Analysis content */
        #analysisContent {
            height: calc(100vh - 200px);
            overflow-y: auto;
            padding: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-center mb-4">Cyborg ZOSCII Encoder/Verifier</h1>
        
        <!-- Simple tabs without Bootstrap -->
        <div class="nav-tabs">
            <div class="nav-item">
                <button class="nav-link active" id="encoder-tab" onclick="showTab('encoder')">Verifier</button>
            </div>
            <div class="nav-item">
                <button class="nav-link" id="analysis-tab" onclick="showTab('analysis')">Analysis</button>
            </div>
        </div>
        
        <div class="tab-content">
            <!-- Verifier Tab -->
            <div class="tab-pane active" id="encoder">
                <div class="encoder-content">
                    <!-- ROM File Drop Zone -->
                    <div class="mb-3">
                        <div id="romDropZone" class="drop-zone">
                            <div>Drop ROM FILE here to encode or verify quality<br>or click to browse</div>
                        </div>
                        <small class="text-muted">Supported formats: ROM, BIN, or any binary file</small>
                        <input type="file" id="romFileInput" style="display: none;" accept="*">
                    </div>
                    
                    <!-- Text Data Drop Zone -->
                    <div class="mb-3">
                        <div id="zosciiDropZone" class="drop-zone">
                            <div>Drop BINARY or TEXT FILE here<br>or click to browse</div>
                        </div>
                        <small class="text-muted">Test message to check ROM compatibility</small>
                        <textarea id="textInput" class="form-control mt-2" placeholder="Type a sample message to test ROM coverage..."></textarea>
                        <input type="file" id="textFileInput" style="display: none;" accept=".txt">
                        
                        <div class="mt-3">
                            <label for="encodingSelect" class="form-label">Character Encoding:</label>
                            <select class="form-select" id="encodingSelect">
                                <option value="ascii">ASCII</option>
                                <option value="ebcdic">EBCDIC</option>
                                <option value="petscii">PETSCII</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <!-- Buttons -->
                <div class="text-end mb-4">
                    <button type="button" class="btn btn-secondary me-2" id="clearBtn">Clear</button>
                    <button type="button" class="btn btn-primary" id="verifyBtn" disabled>Verify ROM</button>
                </div>
            </div>
            
            <!-- Analysis Tab -->
            <div class="tab-pane" id="analysis">
                <div class="mt-4" id="analysisContent">
                    <p class="text-muted">Verify a ROM first to see quality analysis results.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
// Cyborg ZOSCII v20250805
// (c) 2025 Cyborg Unicorn Pty Ltd.
// This software is released under MIT License.

var g_arrRomData = null;
var g_strTextData = "";
var g_objEncodingResult = null;
var g_BITTAGE = 16;		// 16 or 32 bits
var g_arrBinaryInputData = null; 

var g_objLeakageTracker = {
    addressUsage: {},           // address -> count
    positionMap: {},            // address -> [positions where used]
    leakedPatterns: [],         // Array of leaked frequency patterns
    securityReduction: 0.0      // Running security loss calculation
};

window.onload = function()
{
    setupDropZones();
    setupButtons();
};

function calculateROMStrengthGeneral(objEncodingResult_a)
{
    var intI;
    var fltLogSum = 0.0;
    
    for (intI = 0; intI < 256; intI++)
    {
        if (objEncodingResult_a.romCounts[intI] > 0)
        {
            fltLogSum += Math.log10(objEncodingResult_a.romCounts[intI]);
        }
    }
    
    return fltLogSum;
}

// now caters for duplicate which have two real meanings...
// 1. it can indicate less security if the type of data encoded is known
// 2. no impact to security if the type of data encoded is NOT known
//
// note: leakage is only currently displayed for files larger than 65535 bytes because of performance reasons
//		 and anything near there with a good ROM doesn't affect security strength
//		 (the leakage indicator is purely to identify known data for small encoded values)
function calculateROMStrengthFileWithLeakage(objEncodingResult_a, blnDataTypeKnown = false)
{
    var intI;
    var fltLogSum = 0.0;
    
    if (!blnDataTypeKnown) 
    {
        // Scenario 2: Data type unknown - use original calculation
        // Address repetitions don't reveal semantic meaning
        for (intI = 0; intI < 256; intI++)
        {
            if (objEncodingResult_a.inputCounts[intI] > 0 && objEncodingResult_a.romCounts[intI] > 0)
            {
                fltLogSum += objEncodingResult_a.inputCounts[intI] * Math.log10(objEncodingResult_a.romCounts[intI]);
            }
        }
        return fltLogSum;
    }
    else
    {
        // Scenario 1: Data type known - calculate leakage reduction for THIS FILE
        
        // Build frequency distribution for this specific file
        var arrFrequencies = [];
        var intTotalInputLength = 0;
        
        for (intI = 0; intI < 256; intI++)
        {
            if (objEncodingResult_a.inputCounts[intI] > 0)
            {
                arrFrequencies.push({
                    frequency: objEncodingResult_a.inputCounts[intI],
                    romCount: objEncodingResult_a.romCounts[intI]
                });
                intTotalInputLength += objEncodingResult_a.inputCounts[intI];
            }
        }
        
        // Sort by frequency (highest leak risk first)
        arrFrequencies.sort((a, b) => b.frequency - a.frequency);
        
        // Calculate expected unique addresses for THIS FILE's encoding
        var fltExpectedUniqueAddresses = 0;
        
        for (intI = 0; intI < arrFrequencies.length; intI++)
        {
            var objFreq = arrFrequencies[intI];
            // Expected unique addresses for this character type
            var fltUnique = objFreq.romCount * (1 - Math.pow(1 - 1/objFreq.romCount, objFreq.frequency));
            fltExpectedUniqueAddresses += fltUnique;
        }
        
        // File security is based on unique address count for THIS FILE
        return Math.log10(fltExpectedUniqueAddresses);
    }
}

function checkEncodeReady() 
{
    var blnReady = g_arrRomData && ((g_strTextData && g_strTextData.length > 0) || (g_arrBinaryInputData && g_arrBinaryInputData.length > 0));
    document.getElementById("verifyBtn").disabled = !blnReady;
}

function clearLeakageTracker()
{
    g_objLeakageTracker.addressUsage = {};
    g_objLeakageTracker.positionMap = {};
    g_objLeakageTracker.leakedPatterns = [];
    g_objLeakageTracker.securityReduction = 0.0;
}

function displayAnalysis(objEncodingResult_a) 
{
	var intI;
    var strHtml = "<h3>Encoding Results</h3>";
	
    strHtml += "<div class='row'>";
    strHtml += "<div class='col-md-6'>";
    strHtml += "<h5>Input Information</h5>";
	strHtml += "<table class='table table-sm analysis-table'>";
	strHtml += "<colgroup><col style='width: 40%;'><col style='width: 60%;'></colgroup>";

    var strDisplayText = "";
	if (objEncodingResult_a.originalText.length > 100)
	{
        strDisplayText = objEncodingResult_a.originalText.substring(0, 100) + "...";
	}
	else
	{
        strDisplayText = objEncodingResult_a.originalText;
	}
    strHtml += "<tr><td>>Original Input:</td><td>" + escapeHtml(strDisplayText) + "</td></tr>";

    strHtml += "<tr><td>>Input Length:</td><td>" + objEncodingResult_a.inputLength + " bytes</td></tr>";
    strHtml += "<tr><td>>Encoding:</td><td>" + objEncodingResult_a.encoding.toUpperCase() + "</td></tr>";
    strHtml += "<tr><td>>Addresses Generated:</td><td>" + objEncodingResult_a.addressCount + "</td></tr>";
    strHtml += "</table>";
    strHtml += "</div>";
    
	strHtml += displayROMStrength(objEncodingResult_a);

    // --- Generate Viewer Section ---
    strHtml += "<div class='mt-4'>";
    strHtml += "<h5>Generate Address File</h5>";
    strHtml += "<p>Create the encoded ZOSCII data file:</p>";
    strHtml += "<button class='btn btn-success' id='generateAddressFileBtn'>Generate Address File</button>";
    strHtml += "<div id='viewerResult' class='mt-3'></div>";
    strHtml += "</div>";

    strHtml += "<div class='col-md-6'>";
    strHtml += "<h5>Address List</h5>";
    strHtml += "<div style='max-height: 200px; overflow-y: auto;'>";
    strHtml += "<table class='table table-sm analysis-table'>";
    strHtml += "<thead><tr><th>Index</th><th>Address (Hex)</th><th>Address (Dec)</th></tr></thead>";
    strHtml += "<tbody>";
    
    var intMaxRows = 100;
    for (intI = 0; intI < Math.min(objEncodingResult_a.addresses.length, intMaxRows); intI++) 
    {
        var intAddr = objEncodingResult_a.addresses[intI];
        if (intAddr !== undefined)
        {
            strHtml += "<tr>";
            strHtml += "<td>" + intI + "</td>";
            strHtml += "<td>0x" + intAddr.toString(16).toUpperCase() + "</td>";
            strHtml += "<td>" + intAddr + "</td>";
            strHtml += "</tr>";
        }
    }
    if (objEncodingResult_a.addresses.length > intMaxRows)
    {
        strHtml += "<tr><td colspan='3'><em>... and " + (objEncodingResult_a.addresses.length - intMaxRows) + " more addresses (use 'Generate Address File' to get all)</em></td></tr>";
    }
    
    strHtml += "</tbody></table>";
    strHtml += "</div>";
    strHtml += "</div>";
    strHtml += "</div>";
	
	if (g_arrBinaryInputData && g_arrBinaryInputData.length <= 65535)
	{
		strHtml += displayLeakageAnalysis();
	}

    // --- ROM Strength Section ---
	strHtml += "<div class='mt-4'>";
	strHtml += "<h5>Character Usage</h5>";
    strHtml += "<table class='table table-sm analysis-table'><thead><tr><th>Byte</th><th>Dec</th><th>ROM Count</th><th>Input Count</th><th>Char</th></tr></thead><tbody>";
    
	for (var strByte = 0; strByte < 256; strByte++) 
	{
        var intROMCount = objEncodingResult_a.romCounts[strByte];
		var intInputCount = objEncodingResult_a.inputCounts[strByte];
        var strChar = '';
        var strStyle = "";
		
        if (strByte >= 32 && strByte <= 126) 
		{ 
			// Printable ASCII
            strChar = String.fromCharCode(strByte);
            if (intROMCount >= 5) 
			{
                strStyle = "color:#155724;background:#d4edda;"; // green
            } 
			else 
			{
                strStyle = "color:#721c24;background:#f8d7da;"; // red
            }
        } 
		else 
		{
            strChar = '&nbsp;';
            if (intROMCount >= 5) 
			{
				strStyle = "color:#6c757d;background:#f8f9fa;"; // gray
            } 
			else 
			{
                strStyle = "color:#721c24;background:#f8d7da;"; // red
            }
        }

		var strHexByte = strByte.toString(16).toUpperCase();
		if (strHexByte.length < 2)
		{
			strHexByte = "0" + strHexByte;
		}
		
        strHtml += "<tr style='" + strStyle + "'>";
		strHtml += "<td>0x" + strHexByte + "</td>";
        strHtml += "<td>"+strByte+"</td>";
        strHtml += "<td>"+intROMCount+"</td>";
		strHtml += "<td>"+intInputCount+"</td>";
        strHtml += "<td>"+strChar+"</td>";
        strHtml += "</tr>";
    }
    strHtml += "</tbody></table></div>";
    
    document.getElementById("analysisContent").innerHTML = strHtml;

    // Setup generate viewer button
    document.getElementById("generateAddressFileBtn").addEventListener("click", function() 
    {
        this.disabled = true;
        this.textContent = "Generating...";
        
        var arrAddressBytes;
        var intAddress;
        var intI;
        if (g_BITTAGE === 16)
        {
            arrAddressBytes = new Uint8Array(g_objEncodingResult.addresses.length * 2);
            for (intI = 0; intI < g_objEncodingResult.addresses.length; intI++)
            {
                intAddress = g_objEncodingResult.addresses[intI];
                arrAddressBytes[intI * 2] = intAddress & 0xFF;
                arrAddressBytes[intI * 2 + 1] = (intAddress >> 8) & 0xFF;
            }
        }
        else if (g_BITTAGE === 32)
        {
            arrAddressBytes = new Uint8Array(g_objEncodingResult.addresses.length * 4);
            for (intI = 0; intI < g_objEncodingResult.addresses.length; intI++)
            {
                intAddress = g_objEncodingResult.addresses[intI];
                arrAddressBytes[intI * 4] = intAddress & 0xFF;
                arrAddressBytes[intI * 4 + 1] = (intAddress >> 8) & 0xFF;
                arrAddressBytes[intI * 4 + 2] = (intAddress >> 16) & 0xFF;
                arrAddressBytes[intI * 4 + 3] = (intAddress >> 24) & 0xFF;
            }
        }
        downloadFile(arrAddressBytes, 'zoscii_addresses_' + new Date().getTime() + '.bin', 'application/octet-stream');
        
        var strResultHtml = "<div class='alert alert-success'>";
        strResultHtml += "<strong>Address file generated successfully!</strong><br>";
        strResultHtml += "Binary address file downloaded. Use with separate ZOSCII viewer.";
        strResultHtml += "</div>";
        document.getElementById("viewerResult").innerHTML = strResultHtml;
        
        this.disabled = false;
        this.textContent = "Generate Address File";
    });
}

function displayLeakageAnalysis()
{
    var intUniqueAddresses = 0;
    var strAddress;
    var strHtml = "";
    
    // Count unique addresses
    for (strAddress in g_objLeakageTracker.addressUsage) 
    {
        if (g_objLeakageTracker.addressUsage.hasOwnProperty(strAddress)) 
        {
            intUniqueAddresses++;
        }
    }
    
    strHtml += "<div class='mt-4'>";
    strHtml += "<h5>Leakage Analysis</h5>";
    strHtml += "<table class='table table-sm analysis-table'>";
    strHtml += "<colgroup><col style='width: 40%;'><col style='width: 60%;'></colgroup>";
    strHtml += "<tr><td>Total Unique Addresses:</td><td>" + intUniqueAddresses + "</td></tr>";
    strHtml += "<tr><td>Total Leaked Patterns:</td><td>" + g_objLeakageTracker.leakedPatterns.length + "</td></tr>";
    strHtml += "</table>";
    
    if (g_objLeakageTracker.leakedPatterns.length > 0)
    {
        strHtml += "<h6>Detected Leakages</h6>";
        strHtml += "<table class='table table-sm analysis-table'>";
        strHtml += "<thead><tr><th>Address (Hex)</th><th>Frequency</th><th>Positions</th><th>Security Impact</th></tr></thead>";
        strHtml += "<tbody>";
        
        for (var intI = 0; intI < g_objLeakageTracker.leakedPatterns.length; intI++) 
        {
            var objPattern = g_objLeakageTracker.leakedPatterns[intI];
            strHtml += "<tr style='background-color: #f8d7da;'>";  // Light red background for leakages
            strHtml += "<td>0x" + objPattern.address.toString(16).toUpperCase() + "</td>";
            strHtml += "<td>" + objPattern.frequency + "x used</td>";
            strHtml += "<td>[" + objPattern.positions.join(", ") + "]</td>";
            strHtml += "<td>" + objPattern.frequency + "-frequency pattern revealed</td>";
            strHtml += "</tr>";
        }
        
        strHtml += "</tbody></table>";
    }
    else
    {
        strHtml += "<p style='color: #28a745;'><strong>âœ“ No address leakage detected - optimal security</strong></p>";
    }
    
    strHtml += "</div>";
    
    return strHtml;
}

function displayROMStrength(objEncodingResult_a)
{
    var fltGeneralStrength = calculateROMStrengthGeneral(objEncodingResult_a);
    var fltFileStrength = calculateROMStrengthFileWithLeakage(objEncodingResult_a);
    var intCharactersUsed = 0;
    
    for (var intI = 0; intI < 256; intI++)
    {
        if (objEncodingResult_a.inputCounts[intI] > 0)
        {
            intCharactersUsed++;
        }
    }
    
    var fltUtilization = (intCharactersUsed / 256.0) * 100.0;
    
	var strHtml = "<div class='mt-4 col-md-6'>";
	strHtml += "<h5>ROM Strength Analysis</h5>";
	strHtml += "<table class='table table-sm analysis-table'>";
	strHtml += "<colgroup><col style='width: 40%;'><col style='width: 30%;'><col style='width: 30%;'></colgroup>";
	strHtml += "<tr><td>General ROM Capacity:</td><td>~10^" + fltGeneralStrength.toFixed(0) + "</td><td>" + exponentToLayman(fltGeneralStrength) + "</td></tr>";
	strHtml += "<tr><td>This File Security:</td><td>~10^" + fltFileStrength.toFixed(0) + "</td><td>" + exponentToLayman(fltFileStrength) + "</td></tr>";
	strHtml += "<tr><td>Characters Utilized:</td><td>" + intCharactersUsed + " of 256 (" + fltUtilization.toFixed(1) + "%)</td><td></td></tr>";
	strHtml += "</table>";
	strHtml += "</div>";
    
    return strHtml;
}

function downloadFile(objData_a, strFilename_a, strMimeType_a) 
{
    var objBlob = new Blob([objData_a], {type: strMimeType_a});
    var objUrl = URL.createObjectURL(objBlob);
    var objLink = document.createElement('a');
    objLink.href = objUrl;
    objLink.download = strFilename_a;
    document.body.appendChild(objLink);
    objLink.click();
    document.body.removeChild(objLink);
    URL.revokeObjectURL(objUrl);
}

function escapeHtml(strText_a) 
{
    var objDiv = document.createElement('div');
    objDiv.textContent = strText_a;
    return objDiv.innerHTML;
}

function exponentToLayman(fltExponent_a)
{
    var intRounded = Math.round(fltExponent_a);
    var strResult = "";

    if (intRounded <= 0)
    {
        strResult = "1";
    }
    else if (intRounded === 1)
    {
        strResult = "10";
    }
    else
    {
        strResult = "a 1 with " + intRounded.toLocaleString() + " zeros after it";
    }

    return strResult;
}

function formatLargeExponent(fltExponent_a)
{
	var strResult = "";
	
    if (fltExponent_a < 3)
    {
        strResult = "~" + Math.pow(10, fltExponent_a).toFixed(0) + " permutations";
    }
    else if (fltExponent_a < 6)
    {
        strResult = "~" + (Math.pow(10, fltExponent_a) / 1000).toFixed(1) + " thousand permutations";
    }
    else if (fltExponent_a < 9)
    {
        strResult = "~" + (Math.pow(10, fltExponent_a) / 1000000).toFixed(1) + " million permutations";
    }
    else if (fltExponent_a < 12)
    {
        strResult = "~" + (Math.pow(10, fltExponent_a) / 1000000000).toFixed(1) + " billion permutations";
    }
    else if (fltExponent_a < 15)
    {
        strResult = "~" + (Math.pow(10, fltExponent_a) / 1000000000000).toFixed(1) + " trillion permutations";
    }
    else if (fltExponent_a < 82)
    {
        strResult = "More than all atoms in the observable universe (10^" + fltExponent_a.toFixed(0) + " permutations)";
    }
    else if (fltExponent_a < 1000)
    {
        strResult = "Incomprehensibly massive (10^" + fltExponent_a.toFixed(0) + " permutations)";
    }
    else if (fltExponent_a < 1000000)
    {
        strResult = "Beyond all physical comparison (10^" + (fltExponent_a / 1000).toFixed(0) + " thousand permutations)";
    }
    else
    {
        strResult = "Astronomically secure (10^" + (fltExponent_a / 1000000).toFixed(1) + " million permutations)";
    }
	
	return strResult;
}

function setupButtons() 
{
    document.getElementById("clearBtn").addEventListener("click", function() 
    {
        g_arrRomData = null;
        g_strTextData = "";
        g_objEncodingResult = null;
		g_arrBinaryInputData = null; 
        
        var objRomDropZone = document.getElementById("romDropZone");
        objRomDropZone.classList.remove("has-file");
        objRomDropZone.innerHTML = "<div>Drop ROM FILE here to encode or verify quality<br>or click to browse</div>";
        
        var objZosciiDropZone = document.getElementById("zosciiDropZone");
        objZosciiDropZone.classList.remove("has-file");
        objZosciiDropZone.innerHTML = "<div>Drop BINARY or TEXT FILE here<br>or click to browse</div>";
        
        document.getElementById("textInput").value = "";
        document.getElementById("analysisContent").innerHTML = "<p class='text-muted'>Verify a ROM first to see quality analysis results.</p>";
        
        checkEncodeReady();
    });
    
	document.getElementById("verifyBtn").addEventListener("click", function() 
	{
		if (!g_arrRomData || (!g_strTextData && !g_arrBinaryInputData)) 
		{
			return;
		}
		
		this.disabled = true;
		this.textContent = "Verifying...";
        
        var strEncoding = document.getElementById("encodingSelect").value;
        var cbConverter = null;
		
		var intMaxSize;
		if (g_BITTAGE === 16)
		{
			intMaxSize = 65536;
		}
		else if (g_BITTAGE === 32)
		{
			intMaxSize = 4294967296;
		}
		
		var intSize = g_arrRomData.length;
		if (intSize > intMaxSize)
		{
			intSize = intMaxSize;
		}
		
		var arrMemoryBlocks = [
			{start: 0, size: intSize}
		];
        
        if (strEncoding === 'petscii')
        {
            cbConverter = petsciiToAscii;
        }
        else if (strEncoding === 'ebcdic')
        {
            cbConverter = ebcdicToAscii;
        }
       
		var varMixedInput = g_arrBinaryInputData || g_strTextData;
		var objResult = toZOSCII(g_arrRomData, varMixedInput, arrMemoryBlocks, cbConverter, 42);
        
		var strDisplayText;
		var intInputLength;
		if (g_arrBinaryInputData) 
		{
			strDisplayText = "Binary file data";
			intInputLength = g_arrBinaryInputData.length;
		} 
		else 
		{
			strDisplayText = g_strTextData;
			intInputLength = g_strTextData.length;
		}

		g_objEncodingResult = {
			success: true,
			addresses: objResult.addresses,
			originalText: strDisplayText,
			inputLength: intInputLength,
			encoding: strEncoding,
			addressCount: objResult.addresses.length,
			inputCounts: objResult.inputCounts,
			romCounts: objResult.romCounts
		};
        
        displayAnalysis(g_objEncodingResult);
        document.getElementById("analysis-tab").click();
        this.disabled = false;
        this.textContent = "Verify ROM";
    });
}

function setupDropZone(strSelector_a, cbOnFileHandler) 
{
    var objDropZone = document.querySelector(strSelector_a);
    
    objDropZone.addEventListener("dragover", function(objEvent_a) 
    {
        objEvent_a.preventDefault();
        this.classList.add("dragover");
    });
    
    objDropZone.addEventListener("dragleave", function(objEvent_a) 
    {
        objEvent_a.preventDefault();
        this.classList.remove("dragover");
    });
    
    objDropZone.addEventListener("drop", function(objEvent_a) 
    {
        objEvent_a.preventDefault();
        this.classList.remove("dragover");
        
        var arrFiles = objEvent_a.dataTransfer.files;
        if (arrFiles.length > 0) 
        {
            cbOnFileHandler(arrFiles[0]);
        }
    });
}

function setupDropZones() 
{
    // ROM file drop zone
    setupDropZone("#romDropZone", function(objFile_a) 
    {
        var objReader = new FileReader();
        objReader.onload = function(objEvent_a) 
        {
            g_arrRomData = new Uint8Array(objEvent_a.target.result);
            var objRomDropZone = document.getElementById("romDropZone");
            objRomDropZone.classList.add("has-file");
            objRomDropZone.innerHTML = "<div>ROM file loaded: " + objFile_a.name + " (" + objFile_a.size + " bytes)</div>";
            checkEncodeReady();
        };
        objReader.readAsArrayBuffer(objFile_a);
    });

    // ROM drop zone click handler
    document.getElementById("romDropZone").addEventListener("click", function() 
    {
        document.getElementById("romFileInput").click();
    });
    
    // ROM file input change handler
    document.getElementById("romFileInput").addEventListener("change", function() 
    {
        if (this.files.length > 0) 
        {
            var objFile = this.files[0];
            var objReader = new FileReader();
            objReader.onload = function(objEvent_a) 
            {
                g_arrRomData = new Uint8Array(objEvent_a.target.result);
                var objRomDropZone = document.getElementById("romDropZone");
                objRomDropZone.classList.add("has-file");
                objRomDropZone.innerHTML = "<div>ROM file loaded: " + objFile.name + " (" + objFile.size + " bytes)</div>";
                checkEncodeReady();
            };
            objReader.readAsArrayBuffer(objFile);
        }
    });
	
    // UNIFIED input file handler
    function handleInputFile(objFile_a) 
    {
        // Clear all previous data
        g_arrBinaryInputData = null;
        g_strTextData = "";
        
        // Always read as binary - let toZOSCII handle it
        var objReader = new FileReader();
        objReader.onload = function(objEvent_a) 
        {
            g_arrBinaryInputData = new Uint8Array(objEvent_a.target.result);
            document.getElementById("textInput").value = "File loaded: " + objFile_a.name + " (" + objFile_a.size + " bytes)";
            var objZosciiDropZone = document.getElementById("zosciiDropZone");
            objZosciiDropZone.classList.add("has-file");
            objZosciiDropZone.innerHTML = "<div>File loaded: " + objFile_a.name + " (" + objFile_a.size + " bytes)</div>";
            checkEncodeReady();
        };
        objReader.readAsArrayBuffer(objFile_a);
    }

    // Input zone drop handler
    setupDropZone("#zosciiDropZone", handleInputFile);
    
    // Input zone click handler  
    document.getElementById("zosciiDropZone").addEventListener("click", function() 
    {
        document.getElementById("textFileInput").click();
    });
    
    // File picker handler
    document.getElementById("textFileInput").addEventListener("change", function() 
    {
        if (this.files.length > 0) 
        {
            handleInputFile(this.files[0]);
        }
    });
    
    // Text typing handler
    document.getElementById("textInput").addEventListener("input", function() 
    {
        // Only allow typing if no file is loaded
        if (!g_arrBinaryInputData) 
        {
            g_strTextData = this.value;
            var objZosciiDropZone = document.getElementById("zosciiDropZone");
            if (g_strTextData) 
            {
                objZosciiDropZone.classList.add("has-file");
                objZosciiDropZone.innerHTML = "<div>Text entered (" + g_strTextData.length + " characters)</div>";
            } 
            else 
            {
                objZosciiDropZone.classList.remove("has-file");
                objZosciiDropZone.innerHTML = "<div>Drop BINARY or TEXT FILE here<br>or click to browse</div>";
            }
            checkEncodeReady();
        }
    });
}

function showTab(strTabName_a) 
{
	var intI;
	
    // Hide all tab panes
    var arrTabPanes = document.querySelectorAll('.tab-pane');
    for (intI = 0; intI < arrTabPanes.length; intI++) 
    {
        arrTabPanes[intI].classList.remove('active');
    }
    
    // Remove active class from all nav links
    var arrNavLinks = document.querySelectorAll('.nav-link');
    for (intI = 0; intI < arrNavLinks.length; intI++) 
    {
        arrNavLinks[intI].classList.remove('active');
    }
    
    // Show selected tab pane
    document.getElementById(strTabName_a).classList.add('active');
    
    // Add active class to selected nav link
    document.getElementById(strTabName_a + '-tab').classList.add('active');
}

function trackAddressUsage(intAddress, intPosition) 
{
    // Track this address usage
    if (!g_objLeakageTracker.addressUsage[intAddress]) 
	{
        g_objLeakageTracker.addressUsage[intAddress] = 0;
        g_objLeakageTracker.positionMap[intAddress] = [];
    }
    
    g_objLeakageTracker.addressUsage[intAddress]++;
    g_objLeakageTracker.positionMap[intAddress].push(intPosition);
    
    // Check for new leakage
    if (g_objLeakageTracker.addressUsage[intAddress] > 1) 
	{
        // LEAKAGE DETECTED!
        var arrPositions = g_objLeakageTracker.positionMap[intAddress];
        var intFrequency = arrPositions.length;
        
        g_objLeakageTracker.leakedPatterns.push({
            address: intAddress,
            frequency: intFrequency,
            positions: arrPositions.slice(), // copy array
            leakType: "FREQUENCY_PATTERN"
        });
        
        //console.log("LEAKAGE: Address 0x" + intAddress.toString(16).toUpperCase() + " reveals " + intFrequency + "-frequency pattern at positions [" + arrPositions.join(', ') + "]");
    }
}

// Cyborg ZOSCII v20250805
// (c) 2025 Cyborg Unicorn Pty Ltd.
// This software is released under MIT License.

// Function to convert string or binary data to ZOSCII address sequence
// arrBinaryData_a: Uint8Array containing the ROM/binary data  
// mixedInputData_a: String or Uint8Array containing the data to convert
// arrMemoryBlocks_a: array of {start: startAddress, size: blockSize} objects
// cbConverter_a: encoding conversion function (e.g., petsciiToAscii, ebcdicToAscii) or null
// intUnmappableChar_a: the native character code to be used if it cannot be mapped to ASCII
// Returns: {addresses: array, inputCounts: array, romCounts: array}

function toZOSCII(arrBinaryData_a, mixedInputData_a, arrMemoryBlocks_a, cbConverter_a, intUnmappableChar_a)
{
    var intStartTime = new Date().getTime();
	
    var intI;
    var intBlock;
    var intResultIndex = 0;
    var intResultCount = 0;
    var intDebugMissing = 0;
    
    var arrByteCounts = new Array(256);
    var arrByteAddresses = new Array(256);
    var arrOffsets = new Array(256);
    var arrInputCounts = new Array(256);
	var intAddress;
	var intByte;
	var intIndex;
	var objBlock;
    
    // Convert input to consistent format
    var arrInputData_a;
    var blnIsString = false;
    
    if (typeof mixedInputData_a === 'string') {
        // Handle string input - convert to UTF-8 bytes
        arrInputData_a = new TextEncoder().encode(mixedInputData_a);
        blnIsString = true;
    } else {
        // Handle Uint8Array input
        arrInputData_a = mixedInputData_a;
        blnIsString = false;
    }
    
    // Initialize counters
    for (intI = 0; intI < 256; intI++)
    {
        arrByteCounts[intI] = 0;
        arrInputCounts[intI] = 0;
    }
	
	clearLeakageTracker();
    
    // Pass 1: Count occurrences by iterating through blocks
    for (intBlock = 0; intBlock < arrMemoryBlocks_a.length; intBlock++)
    {
        objBlock = arrMemoryBlocks_a[intBlock];
        for (intAddress = objBlock.start; intAddress < (objBlock.start + objBlock.size); intAddress++)
        {
            intByte = arrBinaryData_a[intAddress];
            arrByteCounts[intByte]++;
        }
    }
    
    // Pass 2: Pre-allocate exact-sized arrays
    for (intI = 0; intI < 256; intI++)
    {
        arrByteAddresses[intI] = new Array(arrByteCounts[intI]);
        arrOffsets[intI] = 0;
    }
    
    // Pass 3: Populate arrays by iterating through blocks
    for (intBlock = 0; intBlock < arrMemoryBlocks_a.length; intBlock++)
    {
        objBlock = arrMemoryBlocks_a[intBlock];
        for (intAddress = objBlock.start; intAddress < (objBlock.start + objBlock.size); intAddress++)
        {
            intByte = arrBinaryData_a[intAddress];
            arrByteAddresses[intByte][arrOffsets[intByte]] = intAddress;
			arrOffsets[intByte]++;
        }
    }
    
    // Build result array with random addresses - pre-allocate and avoid push()
    for (intI = 0; intI < arrInputData_a.length; intI++)
    {
        intIndex = arrInputData_a[intI];  // Direct byte value
        
        // Apply encoding conversion if provided
        if (cbConverter_a)
        {
            intIndex = cbConverter_a(intIndex, intUnmappableChar_a);
        }
        
        if (intIndex >= 0 && intIndex < 256 && arrByteAddresses[intIndex] && arrByteAddresses[intIndex].length > 0)
        {
            intResultCount++;
        }
        else
        {
            intDebugMissing++;
            if (intDebugMissing <= 10)
            {
                var strHexByte = arrInputData_a[intI].toString(16).toUpperCase();
                if (strHexByte.length < 2) strHexByte = "0" + strHexByte;
                
                if (blnIsString) {
                    console.log("Missing character: '" + String.fromCharCode(arrInputData_a[intI]) + "' (code " + arrInputData_a[intI] + "/0x" + strHexByte + " -> " + intIndex + ")");
                } else {
                    console.log("Missing byte: " + arrInputData_a[intI] + " (0x" + strHexByte + " -> " + intIndex + ")");
                }
            }
        }
    }

    if (blnIsString) {
        console.log("Characters found in ROM: " + intResultCount);
        console.log("Characters missing from ROM: " + intDebugMissing);
    } else {
        console.log("Bytes found in ROM: " + intResultCount);
        console.log("Bytes missing from ROM: " + intDebugMissing);
    }

    var arrResult = new Array(intResultCount);

    for (intI = 0; intI < arrInputData_a.length; intI++)
    {
        intIndex = arrInputData_a[intI];  // Direct byte value
        
        // Apply encoding conversion if provided
        if (cbConverter_a)
        {
            intIndex = cbConverter_a(intIndex, intUnmappableChar_a);
        }

        if (intIndex >= 0 && intIndex < 256 && arrByteAddresses[intIndex] && arrByteAddresses[intIndex].length > 0)
        {
            arrInputCounts[intIndex]++;
            var intRandomPick = Math.floor(Math.random() * arrByteAddresses[intIndex].length);
            arrResult[intResultIndex] = arrByteAddresses[intIndex][intRandomPick];
			if (arrBinaryData_a.length <= 65535)
			{
				trackAddressUsage(arrByteAddresses[intIndex][intRandomPick], intResultIndex);
			}
			intResultIndex++;
        }
    }

    var intEndTime = new Date().getTime();
    var intElapsedMs = intEndTime - intStartTime;
    
    console.log("ZOSCII Performance:");
    console.log("- Binary size: " + arrBinaryData_a.length + " bytes");
    console.log("- Input length: " + arrInputData_a.length + (blnIsString ? " characters" : " bytes"));
    console.log("- Memory blocks: " + arrMemoryBlocks_a.length);
    console.log("- Execution time: " + intElapsedMs + "ms");
    console.log("- Output addresses: " + arrResult.length);
    
    return {
        addresses: arrResult,
        inputCounts: arrInputCounts,
		romCounts: arrByteCounts
    };
}

// Function to convert PETSCII character codes to ASCII character codes
// intPetsciiChar_a: PETSCII character code (0-255)
// intUnmappableChar_a: the native character code to be used if it cannot be mapped to ASCII
// Returns: ASCII character code or intUnmappableChar_a (suggested *) for unmappable characters
function petsciiToAscii(intPetsciiChar_a, intUnmappableChar_a)
{
    var arrPetsciiToAsciiMap = [
        // 0-31: Control characters
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a,
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a,
        
        // 32-63: Space, digits, punctuation (direct ASCII mapping)
        32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
        
        // 64-95: @A-Z[\]^_ (direct ASCII mapping)
        64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
        
        // 96-255: Everything else
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a,
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a,
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a,
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a,
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a,
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a,
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a,
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a,
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a,
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a
    ];
    
    return arrPetsciiToAsciiMap[intPetsciiChar_a];
}

// Function to convert EBCDIC character codes to ASCII character codes
// intEbcdicChar_a: EBCDIC character code (0-255)
// intUnmappableChar_a: the native character code to be used if it cannot be mapped to ASCII
// Returns: ASCII character code or intUnmappableChar_a (suggested) for unmappable characters
function ebcdicToAscii(intEbcdicChar_a, intUnmappableChar_a)
{
    var arrEbcdicToAsciiMap = [
        // 0-63: Control/special
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a,
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a,
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a,
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a,
        
        // 64-79: Space and some punctuation
        32, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, 46, 60, 40, 43, 124, // Space .....<(+|
        
        // 80-95: & and punctuation
        38, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, 33, 36, intUnmappableChar_a, 41, 59, intUnmappableChar_a, // &.........!$.).;.
        
        // 96-111: - and punctuation
        45, 47, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, 44, 37, 95, 62, 63, // -/........,%_>?
        
        // 112-127: More punctuation
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, 96, 58, 35, 64, 39, 61, 34, // .........`:#@'="
        
        // 128: Control
        intUnmappableChar_a,
        
        // 129-137: a-i
        97, 98, 99, 100, 101, 102, 103, 104, 105,
        
        // 138-144: Control/special
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a,
        
        // 145-153: j-r  
        106, 107, 108, 109, 110, 111, 112, 113, 114,
        
        // 154-161: Control/special
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a,
        
        // 162-169: s-z
        115, 116, 117, 118, 119, 120, 121, 122,
        
        // 170-192: Control/special
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a,
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a,
        
        // 193-201: A-I
        65, 66, 67, 68, 69, 70, 71, 72, 73,
        
        // 202-208: Control/special
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a,
        
        // 209-217: J-R
        74, 75, 76, 77, 78, 79, 80, 81, 82,
        
        // 218-225: Control/special
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a,
        
        // 226-233: S-Z
        83, 84, 85, 86, 87, 88, 89, 90,
        
        // 234-239: Control/special
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a,
        
        // 240-249: 0-9
        48, 49, 50, 51, 52, 53, 54, 55, 56, 57,
        
        // 250-255: Control/special
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a
    ];
    
    return arrEbcdicToAsciiMap[intEbcdicChar_a];
}
	</script>
</body>
</html>