<!DOCTYPE html>
<html>
<head>
    <title>ZOSCII Encoder / Verifier</title>
    <style>
        html, body {
            height: 100vh;
            overflow: hidden;
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }
        .container {
            height: 100vh;
            max-width: 100%;
            overflow: hidden;
            padding: 20px;
            box-sizing: border-box;
        }
        .text-center { text-align: center; }
        .mb-4 { margin-bottom: 1.5rem; }
        .mt-4 { margin-top: 1.5rem; }
        .mt-3 { margin-top: 1rem; }
        .mt-2 { margin-top: 0.5rem; }
        .mb-3 { margin-bottom: 1rem; }
        .me-2 { margin-right: 0.5rem; }
        .text-end { text-align: right; }
        .text-muted { color: #6c757d; }
        
        /* Tab styling */
.nav-tabs {
    list-style: none;
    padding: 0;
    margin: 0 0 20px 0;
    border-bottom: 1px solid #dee2e6;
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.nav-left {
    display: flex;
    align-items: center;
}

.nav-right {
    display: flex;
    align-items: center;
    gap: 8px;
}

.nav-item {
    margin-right: 5px;
}
.nav-right .btn {
    padding: 6px 12px;
    margin: 0;
    font-size: 13px;
    height: 32px; /* Match approximate tab height */
}
        .nav-link {
            display: block;
            padding: 8px 16px;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-bottom: none;
            cursor: pointer;
            text-decoration: none;
            color: #495057;
        }
        .nav-link.active {
            background-color: white;
            border-bottom: 1px solid white;
        }
        .nav-link:hover {
            background-color: #e9ecef;
        }
        
        /* Tab content */
        .tab-content {
            height: calc(100vh - 280px);
            overflow: hidden;
        }
        .tab-pane {
            height: 100%;
            overflow: hidden;
            display: none;
        }
        .tab-pane.active {
            display: block;
        }
@media (max-width: 768px) {
    .nav-tabs {
        flex-direction: column;
        gap: 10px;
    }
    
    .nav-left {
        order: 1;
    }
    
    .nav-right {
        order: 2;
        justify-content: center;
        width: 100%;
    }
    
    .nav-right .btn {
        flex: 1;
        max-width: 120px;
    }
}
.readme-tab {
    background-color: red !important;
    color: yellow !important;
}
.readme-tab:hover {
    background-color: red !important;
    color: yellow !important;
}
.readme-tab.active {
    background-color: red !important;
    color: yellow !important;
}
        
        .encoder-content {
            height: calc(100vh - 330px);
        }
        
        /* Drop zones */
        .drop-zone {
            border: 3px dashed #ccc;
            border-radius: 10px;
            text-align: center;
            font-size: 18px;
            cursor: pointer;
            color: #ccc;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }
        .drop-zone.dragover {
            border-color: #007bff;
            color: #007bff;
            background-color: #f8f9fa;
        }
        .drop-zone.has-file {
            border-color: #28a745;
            color: #28a745;
            background-color: #d4edda;
        }
        #romDropZone {
            height: calc((100vh - 400px) * 0.25);
        }
		#romDropZone:hover {
			border-color: #007bff;
			color: #007bff;
			background-color: #f8f9fa;
		}
        #zosciiDropZone {
            height: calc((100vh - 500px) * 0.3);
        }
		#zosciiDropZone:hover {
			border-color: #007bff;
			color: #007bff;
			background-color: #f8f9fa;
		}
        
        /* Form elements */
        #textInput, .form-control {
            width: 100%;
            height: calc((100vh - 550px) * 0.4);
            padding: 8px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            resize: none;
            box-sizing: border-box;
            font-family: monospace;
        }
        .form-select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ced4da;
            border-radius: 4px;
        }
        .form-label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        /* Buttons */
        .btn {
            padding: 8px 16px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .btn-primary {
            background-color: #007bff;
            color: white;
        }
        .btn-success {
            background-color: #28a745;
            color: white;
        }
        .btn-secondary {
            background-color: #6c757d;
            color: white;
        }
        .btn:disabled {
            background-color: #6c757d;
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn:hover:not(:disabled) {
            opacity: 0.9;
        }
        
        /* Tables */
        .table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        .table td, .table th {
            padding: 8px;
            border-bottom: 1px solid #dee2e6;
            text-align: left;
        }
        .table th {
            background-color: #f8f9fa;
            font-weight: bold;
        }
        .analysis-table {
            font-size: 12px;
        }
        
        /* Alerts */
        .alert {
            padding: 15px;
            border-radius: 4px;
            margin: 10px 0;
        }
        .alert-success {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }
        
        /* Analysis content */
#analysisContent {
	height: calc(100vh - 290px);
	overflow-y: auto;
	overflow-x: hidden;
	margin: 0;
	padding: 0;
	position: relative;
}

#readmeContent {
    height: calc(100vh - 290px);
    overflow-y: auto;
    overflow-x: hidden;
    margin: 0;
    padding: 0;
    position: relative;
}

.scrollable-content {
    height: auto;
    padding: 0;
    margin: 20px;
    display: block;
}

/* Content spacing */
.scrollable-content h3,
.scrollable-content h4,
.scrollable-content p,
.scrollable-content ul,
.scrollable-content ol,
.scrollable-content div {
    margin: 15px 0;
}

.scrollable-content li {
    margin: 5px 0;
}
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-center mb-4">ZOSCII Encoder / Verifier</h1>
    
		<!-- Security Warning - Prominent placement -->
		<div class="alert alert-warning text-center mb-4" style="border: 2px solid #ff6b35; background-color: #fff3cd; font-weight: bold;">
			!!! <strong>SECURITY WARNING:</strong> FOR YOUR GREATER SECURITY - DO NOT RUN THIS ENCODER ONLINE FROM AN UNTRUSTED WEBSITE !!!<br>
			<small>Download this tool from the official GitHub repository and run it locally on your own computer. This is JavaScript not minified so you can see the code.</small>
		</div>
	
        <!-- Simple tabs without Bootstrap -->
		<div class="nav-tabs">
			<div class="nav-left">
				<div class="nav-item">
					<button class="nav-link readme-tab" id="readme-tab" onclick="showTab('readme')">Read Me First</button>
				</div>
				<div class="nav-item">
					<button class="nav-link active" id="encoder-tab" onclick="showTab('encoder')">Verifier</button>
				</div>
				<div class="nav-item">
					<button class="nav-link" id="analysis-tab" onclick="showTab('analysis')">Analysis</button>
				</div>
			</div>
			<div class="nav-right">
				<button type="button" class="btn btn-secondary me-2" id="clearBtn">Clear</button>
				<button type="button" class="btn btn-primary" id="verifyBtn" disabled>Verify ROM</button>
			</div>
		</div>
        
        <div class="tab-content">
            <!-- Read Me Tab -->
            <div class="tab-pane" id="readme">
<div class="mt-4" id="readmeContent">
	<div class="scrollable-content">
		<h3>Security Best Practices for ZOSCII Encoder</h3>
		
		<div class="alert alert-warning mb-4">
			<strong>CRITICAL:</strong> This tool handles sensitive data. Follow these security practices to protect your assets.
		</div>

		<div style="background-color: #ffcccc; padding: 15px; border: 2px solid red; margin-bottom: 20px; font-family: Arial, sans-serif;">
		  <h2 style="color: red;">!!! CRITICAL DISCLAIMER: DATA AT RISK !!!</h2>
		  <p><strong>By using the ZOSCII Encoder / Verifier, you acknowledge that Cyborg Unicorn Pty Ltd and associated developers are not responsible for any outcomes, including financial losses, data loss or other damage, resulting from your use or misuse of this software.</strong></p>
		  <p><strong>Key Risks:</strong></p>
		  <ul>
			<li><strong>ROM File Loss</strong>: Losing the ROM file used for encoding will permanently prevent recovery of encoded data, resulting in loss of funds or any other information that you may have encoded.</li>
			<li><strong>Misuse</strong>: Pasting encoded ZOSCII data (e.g., address lists) directly into e.g. a cryptocurrency wallet without decoding may cause financial loss.</li>
			<li><strong>Low-Entropy ROMs</strong>: Using weak ROM files may compromise security, risking theft.</li>
			<li><strong>Online Use</strong>: Running this tool on untrusted websites may expose keys and sensitive data to theft. Download from the official GitHub repository and run offline.</li>
		  </ul>
		  <p><strong>Your Responsibilities:</strong></p>
		  <ul>
			<li>Download only from the official GitHub repository: <a href="https://github.com/PrimalNinja/cyborgzoscii" target="_blank">https://github.com/PrimalNinja/cyborgzoscii</a>.</li>
			<li>Run offline on a trusted computer.</li>
			<li>Securely back up ROM files in multiple locations.</li>
			<li>Test with dummy data before encoding real data.</li>
		  </ul>
		  <p>Cyborg Unicorn Pty Ltd acts responsibly and will publish any discovered security issues on the official website or GitHub repository. This software is provided “as is” under the MIT License with no warranties. See the <a href="https://github.com/PrimalNinja/cyborgzoscii/blob/master/LICENSE" target="_blank">MIT LICENSE</a> file in the repository for full terms.</p>
		</div>

		<h4>Understanding ZOSCII</h4>
		
		<p>Securing data digitally is about encoding the data. Below is a simplified explanation of how ZOSCII differs from other approaches.</p>
		
<h5>Encryption vs ZOSCII Encoding</h5>
<p><strong>Encryption</strong> transforms your data using complex mathematical algorithms and encryption keys into a secured file. It's like putting your valuables into a SAFE - only you know the combination. While strong encryptions would take an eternity to crack with today's computers, technological breakthroughs could potentially decrypt files much faster. Importantly: your original data, whether accessible or not, is contained within that encrypted file.</p>

<p><strong>ASCII Encoding</strong> represents characters (alphabet 'A'-'Z', numbers '0'-'9', etc.) using standardized codes. When you store an 'A', you're actually storing an ASCII value that points to the letter 'A' in your computer's character table - the actual letter isn't stored, just a reference to it.</p>

<p><strong>ZOSCII is loosely based on ASCII</strong> but uses direct memory addresses instead of lookup tables. Rather than storing offsets to characters in an ASCII table like ASCII encoding, ZOSCII stores direct addresses to find the required data. ZOSCII is NOT encryption - it's a form of encoding that provides security through obscurity and plausible deniability rather than mathematical complexity.</p>
		
<h5>How ZOSCII Encoding Works:</h5>

<ol>
    <li><strong>ROM Files:</strong> You create or obtain a "ROM file" - any binary file (could be a photo, music, executable, etc.) that contains diverse byte values</li>
    <li><strong>Address Mapping:</strong> For each byte value (0-255) in your data, the ZOSCII encoder finds all occurrences of that value within your ROM file and records their addresses</li>
    <li><strong>Non-Discriminatory Selection:</strong> When encoding the ASCII letter 'A' (value 65), the ZOSCII encoder finds every occurrence of byte value 65 in the ROM. A typical 64KB ROM contains ~255 occurrences of each byte value. But which occurrence should we use? Well, any are fine - in fact, why should we discriminate? Let's pull one occurrence out of a hat and use that!</li>
    <li><strong>Random for Everything:</strong> ZOSCII does this non-discriminatory random selection for every byte (0-255) in your input data</li>
    <li><strong>Address File Output:</strong> The result is an "address file" - a list of memory addresses that, when used with your ROM, recreates your original data</li>
</ol>
		
<h5>ZOSCII's Unique Security Properties</h5>
<p>The revolutionary aspect: because ZOSCII refuses to discriminate between multiple possible addresses for each byte, the <strong>same data can be encoded millions of different ways</strong>. This non-discriminatory approach means address sequences #0001, #0002, #0003, #0004 could represent "Hello", "BINGO", "Apple", "AAAAA", "BBBBB", music data, image data - mathematically, almost any encoding can decode to almost anything you want.</p>
		
		<p><strong>Perfect Deniability:</strong> There are no clues, markers, or patterns in an address file to indicate what the original data was or even that it is a ZOSCII file at all. Without the ROM file, the address file is meaningless random numbers.</p>
		
		<h5>What is Entropy?</h5>
		<p><strong>Entropy</strong> measures randomness and unpredictability in data. High entropy means data appears random with no obvious patterns. Low entropy data (like text files) has predictable patterns that can be exploited. For ZOSCII:</p>
		<ul>
			<li><strong>High Entropy ROM:</strong> Binary files, executables, images, compressed files - provide maximum security</li>
			<li><strong>Low Entropy ROM:</strong> Text files, repeated data - reduce security and provide fewer encoding options</li>
			<li><strong>Balanced Distribution:</strong> Best ROMs contain roughly equal amounts of each byte value (0-255)</li>
		</ul>

		<h4>Network Security</h4>
		<ul>
			<li><strong>Run Offline Only:</strong> Disconnect from the internet before using this tool with real data</li>
			<li><strong>Local Files Only:</strong> Keep all ROM files on local storage - never upload ROMs to cloud services. Even if you believe the files are secure online, take added precautions relating to other things that can happen online - for example, if you used an image from a website as a ROM, they might one day change it, or reencoded it, or even if it looks the same, change it's format - making the ROM file now incompatible with your ZOSCII file</li>
		</ul>

		<h4>File Handling</h4>
		<ul>
			<li><strong>Secure Deletion:</strong> Use secure delete tools (not regular delete) for temporary files</li>
			<li><strong>Test First:</strong> Always verify successful decoding first</li>
			<li><strong>Keep Originals Safe:</strong> Never delete original data until you've verified successful decoding</li>
		</ul>

		<h4>Data Protection</h4>

		<div class="alert alert-warning text-center mb-4" style="border: 2px solid #ff6b35; background-color: #fff3cd; font-weight: bold;">
			!!! <strong>IMPORTANT:</strong> ENCODING ROM files as ZOSCII !!!<br>
			<small>If you want added security you can encode ROM files as ZOSCII but you must remember if you do this, you must keep each ROM file at least one layer higher than however many embedded ZOSCII encodings you have.  Do not encode your ROM file with ZOSCII and throw away your ROM file - that is equivalent to storing a safe key inside the impenetrable safe.</small>
		</div>

		<ul>
			<li><strong>Never Share ROMs:</strong> Your ROM files are unique - sharing them compromises all your encoded keys</li>
			<li><strong>Encoded Key Storage:</strong> Address files can be stored anywhere (even online) if your ROM has sufficient entropy</li>
			<li><strong>ZOSCII Storage:</strong> You can store ZOSCII files inside ZOSCII - each layer you do that adds another layer of 100% security, however you must keep your ROM files accessible somewhere.</li>
			<li><strong>Clean Browser:</strong> Clear browser cache and temporary files after use</li>
			<li><strong>Private Environment:</strong> Use this tool on a trusted, private computer only</li>
			<li><strong>Verify Downloads:</strong> Only download this tool from official GitHub repository</li>
		</ul>

		<h4>ROM Quality and Storage Guidelines</h4>

		<div class="alert alert-warning text-center mb-4" style="border: 2px solid #ff6b35; background-color: #fff3cd; font-weight: bold;">
			!!! <strong>IMPORTANT:</strong> DO NOT LOSE YOUR ROM FILE !!!<br>
			<small>If you lose your ROM file, your data will be lost forever.  Remember - your data is NOT stored within the encoded file and you need that ROM file to recreate your data.</small>
		</div>

		<ul>
			<li><strong>High Entropy:</strong> Use binary files with diverse byte distributions - executables, images, compressed files</li>
			<li><strong>Sufficient Size:</strong> Larger ROM files provide better security (minimum 64KB recommended). This tool uses the first 64KB of any ROM file - larger files are fine, but only the first 64KB will be used for encoding.</li>
			<li><strong>Unknown Content:</strong> ROMs with unpredictable content offer maximum security</li>
			<li><strong>Hide in Plain Sight:</strong> Disguise ROMs as innocent files - family photos, music files, documents, game files</li>
			<li><strong>Multiple Hidden Copies:</strong> Store disguised copies in different locations (USB drives, cloud storage, email attachments to yourself)</li>
			<li><strong>Social Media:</strong> Do NOT trust ROMs you uploaded as photos or videos (the platform may compress them or remove them)</li>
			<li><strong>Version Control:</strong> Keep track of which ROM version was used for each encoding (subtle filename variations)</li>
		</ul>

		<div class="alert alert-warning text-center mb-4" style="border: 2px solid #ff6b35; background-color: #fff3cd; font-weight: bold;">
			!!! <strong>IMPORTANT:</strong> VERSIONS OF ROM FILES !!!<br>
			<small>If you lose the exact version of the ROM file you used to encode your data, your data will likely be lost forever.  Remember - your data is NOT stored within the encoded file and you need that ROM file to recreate your data.</small>
		</div>

		<h4>Quick Security Checklist</h4>
		<div style="background:#f8f9fa; margin:15px; border-left:4px solid #28a745;">
			<div style="margin:15px;">
				<p><strong>Before encoding real data:</strong></p>
				<ol>
					<li>Downloaded tool from official GitHub repository - one which you can see the sourcecode</li>
					<li>Running tool on offline computer</li>
					<li>Using different ROM files for different types of information</li>
					<li>ROM files have high entropy and good byte distribution</li>
					<li>ROM files disguised as innocent data with multiple hidden backup copies</li>
					<li>Tested encoding/decoding process with dummy data first</li>
					<li><strong>WARNING:</strong> If you lose your ROMs, you lose your data permanently - there is no recovery!</li>
				</ol>
			</div>
		</div>
<div class="mt-4 text-muted">
	<small><strong>Remember:</strong> ZOSCII security depends entirely on ROM secrecy and entropy. High-entropy ROMs can be stored anywhere when disguised properly. Address files are meaningless without the ROM, providing perfect plausible deniability - they appear as random numbers that could decode to anything.</small>
</div>

<h4>In the Official GitHub Repository</h4>
<ul>
    <li><strong>Source Code:</strong> Assembly Language, C, JavaScript, PHP, Python</li>
    <li><strong>Larger ROM Capacities:</strong> Most tools provide optional 32-bit addressing, with easy expansion to 64-bit, 128-bit or higher if ever required</li>
    <li><strong>8-bit Computer Support:</strong> Tools and source code available for encoding and decoding ZOSCII on vintage systems</li>
</ul>


	</div>
</div>
</div>

            <!-- Verifier Tab -->
            <div class="tab-pane active" id="encoder">
                <div class="encoder-content">
                    <!-- ROM File Drop Zone -->
                    <div class="mb-3">
                        <div id="romDropZone" class="drop-zone">
                            <div>Drop ROM FILE here to encode or verify quality<br>or click to browse</div>
                        </div>
                        <small class="text-muted">Supported formats: ROM, BIN, or any binary file</small>
                        <input type="file" id="romFileInput" style="display: none;" accept="*">
                    </div>
                    
                    <!-- Text Data Drop Zone -->
                    <div class="mb-3">
                        <div id="zosciiDropZone" class="drop-zone">
                            <div>Drop BINARY or TEXT FILE here<br>or click to browse</div>
                        </div>
                        <small class="text-muted">Test message to check ROM compatibility</small>
                        <textarea id="textInput" class="form-control mt-2" placeholder="!!! SECURITY WARNING: FOR GREATER SECURITY - DO NOT RUN THIS ENCODER ONLINE FROM AN UNTRUSTED WEBSITE !!! DOWNLOAD THIS TOOL FROM THE OFFICIAL GITHUB REPOSITORY AND RUN IT LOCALLY ON YOUR OWN COMPUTER.  THEN YOU CAN TYPE OR PASTE YOUR DATA HERE TO ENCODED IT INTO ZOSCII."></textarea>
                        <input type="file" id="textFileInput" style="display: none;" accept=".txt">
                        
                        <div class="mt-3">
                            <label for="encodingSelect" class="form-label">Character Encoding:</label>
                            <select class="form-select" id="encodingSelect">
                                <option value="ascii">ASCII</option>
                                <option value="ebcdic">EBCDIC</option>
                                <option value="petscii">PETSCII</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Analysis Tab -->
            <div class="tab-pane" id="analysis">
                <div class="mt-4" id="analysisContent">
                    <p class="text-muted">Verify a ROM first to see quality analysis results.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
// Cyborg ZOSCII v20250805
// (c) 2025 Cyborg Unicorn Pty Ltd.
// This software is released under MIT License.

var g_arrRomData = null;
var g_strTextData = "";
var g_objEncodingResult = null;
var g_BITTAGE = 16;		// 16 or 32 bits
var g_arrBinaryInputData = null; 

var g_objLeakageTracker = {
    addressUsage: {},           // address -> count
    positionMap: {},            // address -> [positions where used]
    leakedPatterns: [],         // Array of leaked frequency patterns
    securityReduction: 0.0      // Running security loss calculation
};

window.onload = function()
{
    setupDropZones();
    setupButtons();
};

function calculateROMStrengthGeneral(objEncodingResult_a)
{
    var intI;
    var fltLogSum = 0.0;
    
    for (intI = 0; intI < 256; intI++)
    {
        if (objEncodingResult_a.romCounts[intI] > 0)
        {
            fltLogSum += Math.log10(objEncodingResult_a.romCounts[intI]);
        }
    }
    
    return fltLogSum;
}

// now caters for duplicate which have two real meanings...
// 1. it can indicate less security if the type of data encoded is known
// 2. no impact to security if the type of data encoded is NOT known
//
// note: leakage is only currently displayed for files larger than 65535 bytes because of performance reasons
//		 and anything near there with a good ROM doesn't affect security strength
//		 (the leakage indicator is purely to identify known data for small encoded values)
function calculateROMStrengthFileWithLeakage(objEncodingResult_a, blnDataTypeKnown_a)
{
	var blnDataTypeKnown = blnDataTypeKnown_a;
	if (blnDataTypeKnown === undefined) { blnDataTypeKnown = false; }

    var intI;
    var fltLogSum = 0.0;
    
    if (!blnDataTypeKnown) 
    {
        // Scenario 2: Data type unknown - use original calculation
        // Address repetitions don't reveal semantic meaning
        for (intI = 0; intI < 256; intI++)
        {
            if (objEncodingResult_a.inputCounts[intI] > 0 && objEncodingResult_a.romCounts[intI] > 0)
            {
                fltLogSum += objEncodingResult_a.inputCounts[intI] * Math.log10(objEncodingResult_a.romCounts[intI]);
            }
        }
        return fltLogSum;
    }
    else
    {
        // Scenario 1: Data type known - calculate leakage reduction for THIS FILE
        
        // Build frequency distribution for this specific file
        var arrFrequencies = [];
        var intTotalInputLength = 0;
        
        for (intI = 0; intI < 256; intI++)
        {
            if (objEncodingResult_a.inputCounts[intI] > 0)
            {
                arrFrequencies.push({
                    frequency: objEncodingResult_a.inputCounts[intI],
                    romCount: objEncodingResult_a.romCounts[intI]
                });
                intTotalInputLength += objEncodingResult_a.inputCounts[intI];
            }
        }
        
        // Sort by frequency (highest leak risk first)
		arrFrequencies.sort(function(a, b) 
		{
			return b.frequency - a.frequency;
		});
        
        // Calculate expected unique addresses for THIS FILE's encoding
        var fltExpectedUniqueAddresses = 0;
        
        for (intI = 0; intI < arrFrequencies.length; intI++)
        {
            var objFreq = arrFrequencies[intI];
            // Expected unique addresses for this character type
            var fltUnique = objFreq.romCount * (1 - Math.pow(1 - 1/objFreq.romCount, objFreq.frequency));
            fltExpectedUniqueAddresses += fltUnique;
        }
        
        // File security is based on unique address count for THIS FILE
        return Math.log10(fltExpectedUniqueAddresses);
    }
}

function checkEncodeReady() 
{
    var blnReady = g_arrRomData && ((g_strTextData && g_strTextData.length > 0) || (g_arrBinaryInputData && g_arrBinaryInputData.length > 0));
    document.getElementById("verifyBtn").disabled = !blnReady;
}

function clearLeakageTracker()
{
    g_objLeakageTracker.addressUsage = {};
    g_objLeakageTracker.positionMap = {};
    g_objLeakageTracker.leakedPatterns = [];
    g_objLeakageTracker.securityReduction = 0.0;
}

function displayAnalysis(objEncodingResult_a) 
{
	var intI;
    var strHtml = '<div class="scrollable-content"><h3>Encoding Results</h3>';
	
    strHtml += "<div class='row'>";
    strHtml += "<div class='col-md-6'>";
    strHtml += "<h5>Input Information</h5>";
	strHtml += "<table class='table table-sm analysis-table'>";
	strHtml += "<colgroup><col style='width: 40%;'><col style='width: 60%;'></colgroup>";

    var strDisplayText = "";
	if (objEncodingResult_a.originalText.length > 100)
	{
        strDisplayText = objEncodingResult_a.originalText.substring(0, 100) + "...";
	}
	else
	{
        strDisplayText = objEncodingResult_a.originalText;
	}
    strHtml += "<tr><td>>Original Input:</td><td>" + escapeHtml(strDisplayText) + "</td></tr>";

    strHtml += "<tr><td>>Input Length:</td><td>" + objEncodingResult_a.inputLength + " bytes</td></tr>";
    strHtml += "<tr><td>>Encoding:</td><td>" + objEncodingResult_a.encoding.toUpperCase() + "</td></tr>";
    strHtml += "<tr><td>>Addresses Generated:</td><td>" + objEncodingResult_a.addressCount + "</td></tr>";
    strHtml += "</table>";
    strHtml += "</div>";
    
	strHtml += displayROMStrength(objEncodingResult_a);

    // --- Generate Viewer Section ---
    strHtml += "<div class='mt-4'>";
    strHtml += "<h5>Generate Address File</h5>";
    strHtml += "<p>Create the encoded ZOSCII data file:</p>";
    strHtml += "<button class='btn btn-success' id='generateAddressFileBtn'>Generate Address File</button>";
    strHtml += "<div id='viewerResult' class='mt-3'></div>";
    strHtml += "</div>";

	if ((g_arrBinaryInputData && g_arrBinaryInputData.length <= 65535) || 
		(!g_arrBinaryInputData && g_strTextData && g_strTextData.length <= 65535))	
	{
		strHtml += displayLeakageAnalysis();
	}

    strHtml += "<div class='col-md-6'>";
    strHtml += "<h5>Address List</h5>";
    strHtml += "<div style='max-height: 200px; overflow-y: auto;'>";
    strHtml += "<table class='table table-sm analysis-table'>";
    strHtml += "<thead><tr><th>Index</th><th>Address (Hex)</th><th>Address (Dec)</th></tr></thead>";
    strHtml += "<tbody>";
    
    var intMaxRows = 100;
    for (intI = 0; intI < Math.min(objEncodingResult_a.addresses.length, intMaxRows); intI++) 
    {
        var intAddr = objEncodingResult_a.addresses[intI];
        if (intAddr !== undefined)
        {
            strHtml += "<tr>";
            strHtml += "<td>" + intI + "</td>";
            strHtml += "<td>0x" + intAddr.toString(16).toUpperCase() + "</td>";
            strHtml += "<td>" + intAddr + "</td>";
            strHtml += "</tr>";
        }
    }
    if (objEncodingResult_a.addresses.length > intMaxRows)
    {
        strHtml += "<tr><td colspan='3'><em>... and " + (objEncodingResult_a.addresses.length - intMaxRows) + " more addresses (use 'Generate Address File' to get all)</em></td></tr>";
    }
    
    strHtml += "</tbody></table>";
    strHtml += "</div>";
    strHtml += "</div>";
    strHtml += "</div>";
	
    // --- ROM Strength Section ---
	strHtml += "<div class='mt-4'>";
	strHtml += "<h5>Character Usage</h5>";
    strHtml += "<table class='table table-sm analysis-table'><thead><tr><th>Byte</th><th>Dec</th><th>ROM Count</th><th>Input Count</th><th>Char</th></tr></thead><tbody>";
    
	for (var strByte = 0; strByte < 256; strByte++) 
	{
        var intROMCount = objEncodingResult_a.romCounts[strByte];
		var intInputCount = objEncodingResult_a.inputCounts[strByte];
        var strChar = '';
        var strStyle = "";
		
        if (strByte >= 32 && strByte <= 126) 
		{ 
			// Printable ASCII
            strChar = String.fromCharCode(strByte);
            if (intROMCount >= 5) 
			{
                strStyle = "color:#155724;background:#d4edda;"; // green
            } 
			else 
			{
                strStyle = "color:#721c24;background:#f8d7da;"; // red
            }
        } 
		else 
		{
            strChar = '&nbsp;';
            if (intROMCount >= 5) 
			{
				strStyle = "color:#6c757d;background:#f8f9fa;"; // gray
            } 
			else 
			{
                strStyle = "color:#721c24;background:#f8d7da;"; // red
            }
        }

		var strHexByte = strByte.toString(16).toUpperCase();
		if (strHexByte.length < 2)
		{
			strHexByte = "0" + strHexByte;
		}
		
        strHtml += "<tr style='" + strStyle + "'>";
		strHtml += "<td>0x" + strHexByte + "</td>";
        strHtml += "<td>"+strByte+"</td>";
        strHtml += "<td>"+intROMCount+"</td>";
		strHtml += "<td>"+intInputCount+"</td>";
        strHtml += "<td>"+strChar+"</td>";
        strHtml += "</tr>";
    }
    strHtml += "</tbody></table></div></div>";
    
    document.getElementById("analysisContent").innerHTML = strHtml;

    // Setup generate viewer button
    document.getElementById("generateAddressFileBtn").addEventListener("click", function() 
    {
        this.disabled = true;
        this.textContent = "Generating...";
        
        var arrAddressBytes;
        var intAddress;
        var intI;
        if (g_BITTAGE === 16)
        {
            arrAddressBytes = new Uint8Array(g_objEncodingResult.addresses.length * 2);
            for (intI = 0; intI < g_objEncodingResult.addresses.length; intI++)
            {
                intAddress = g_objEncodingResult.addresses[intI];
                arrAddressBytes[intI * 2] = intAddress & 0xFF;
                arrAddressBytes[intI * 2 + 1] = (intAddress >> 8) & 0xFF;
            }
        }
        else if (g_BITTAGE === 32)
        {
            arrAddressBytes = new Uint8Array(g_objEncodingResult.addresses.length * 4);
            for (intI = 0; intI < g_objEncodingResult.addresses.length; intI++)
            {
                intAddress = g_objEncodingResult.addresses[intI];
                arrAddressBytes[intI * 4] = intAddress & 0xFF;
                arrAddressBytes[intI * 4 + 1] = (intAddress >> 8) & 0xFF;
                arrAddressBytes[intI * 4 + 2] = (intAddress >> 16) & 0xFF;
                arrAddressBytes[intI * 4 + 3] = (intAddress >> 24) & 0xFF;
            }
        }
        downloadFile(arrAddressBytes, 'zoscii_addresses_' + new Date().getTime() + '.bin', 'application/octet-stream');
        
        var strResultHtml = "<div class='alert alert-success'>";
        strResultHtml += "<strong>Address file generated successfully!</strong><br>";
        strResultHtml += "Binary address file downloaded. Use with separate ZOSCII viewer.";
        strResultHtml += "</div>";
        document.getElementById("viewerResult").innerHTML = strResultHtml;
        
        this.disabled = false;
        this.textContent = "Generate Address File";
    });
}

function displayLeakageAnalysis()
{
    var intUniqueAddresses = 0;
    var strAddress;
    var strHtml = "";
    
    // Count unique addresses
    for (strAddress in g_objLeakageTracker.addressUsage) 
    {
        if (g_objLeakageTracker.addressUsage.hasOwnProperty(strAddress)) 
        {
            intUniqueAddresses++;
        }
    }
    
    strHtml += "<div class='mt-4'>";
    strHtml += "<h5>Leakage Analysis</h5>";
    strHtml += "<table class='table table-sm analysis-table'>";
    strHtml += "<colgroup><col style='width: 40%;'><col style='width: 60%;'></colgroup>";
    strHtml += "<tr><td>Total Unique Addresses:</td><td>" + intUniqueAddresses + "</td></tr>";
    strHtml += "<tr><td>Total Leaked Patterns:</td><td>" + g_objLeakageTracker.leakedPatterns.length + "</td></tr>";
    strHtml += "</table>";
    
    if (g_objLeakageTracker.leakedPatterns.length > 0)
    {
        strHtml += "<h6>Detected Leakages</h6>";
        strHtml += "<table class='table table-sm analysis-table'>";
        strHtml += "<thead><tr><th>Address (Hex)</th><th>Frequency</th><th>Positions</th><th>Security Impact</th></tr></thead>";
        strHtml += "<tbody>";
        
        for (var intI = 0; intI < g_objLeakageTracker.leakedPatterns.length; intI++) 
        {
            var objPattern = g_objLeakageTracker.leakedPatterns[intI];
            strHtml += "<tr style='background-color: #f8d7da;'>";  // Light red background for leakages
            strHtml += "<td>0x" + objPattern.address.toString(16).toUpperCase() + "</td>";
            strHtml += "<td>" + objPattern.frequency + "x used</td>";
            strHtml += "<td>[" + objPattern.positions.join(", ") + "]</td>";
            strHtml += "<td>" + objPattern.frequency + "-frequency pattern revealed</td>";
            strHtml += "</tr>";
        }
        
        strHtml += "</tbody></table>";
    }
    else
    {
        strHtml += "<p style='color: #28a745;'><strong>No address leakage detected - optimal security</strong></p>";
    }
    
    strHtml += "</div>";
    
    return strHtml;
}

function displayROMStrength(objEncodingResult_a)
{
    var fltGeneralStrength = calculateROMStrengthGeneral(objEncodingResult_a);
    var fltFileStrength = calculateROMStrengthFileWithLeakage(objEncodingResult_a);
    var intCharactersUsed = 0;
    
    for (var intI = 0; intI < 256; intI++)
    {
        if (objEncodingResult_a.inputCounts[intI] > 0)
        {
            intCharactersUsed++;
        }
    }
    
    var fltUtilization = (intCharactersUsed / 256.0) * 100.0;
    
	var strHtml = "<div class='mt-4 col-md-6'>";
	strHtml += "<h5>ROM Strength Analysis</h5>";
	strHtml += "<table class='table table-sm analysis-table'>";
	strHtml += "<colgroup><col style='width: 40%;'><col style='width: 30%;'><col style='width: 30%;'></colgroup>";
	strHtml += "<tr><td>General ROM Capacity:</td><td>~10^" + fltGeneralStrength.toFixed(0) + "</td><td>" + exponentToLayman(fltGeneralStrength) + "</td></tr>";
	strHtml += "<tr><td>This File Security:</td><td>~10^" + fltFileStrength.toFixed(0) + "</td><td>" + exponentToLayman(fltFileStrength) + "</td></tr>";
	strHtml += "<tr><td>Characters Utilized:</td><td>" + intCharactersUsed + " of 256 (" + fltUtilization.toFixed(1) + "%)</td><td></td></tr>";
	strHtml += "</table>";
	strHtml += "</div>";
    
    return strHtml;
}

function downloadFile(objData_a, strFilename_a, strMimeType_a) 
{
    var objBlob = new Blob([objData_a], {type: strMimeType_a});
    var objUrl = URL.createObjectURL(objBlob);
    var objLink = document.createElement('a');
    objLink.href = objUrl;
    objLink.download = strFilename_a;
    document.body.appendChild(objLink);
    objLink.click();
    document.body.removeChild(objLink);
    URL.revokeObjectURL(objUrl);
}

function escapeHtml(strText_a) 
{
    var objDiv = document.createElement('div');
    objDiv.textContent = strText_a;
    return objDiv.innerHTML;
}

function exponentToLayman(fltExponent_a)
{
    var intRounded = Math.round(fltExponent_a);
    var strResult = "";

    if (intRounded <= 0)
    {
        strResult = "1";
    }
    else if (intRounded === 1)
    {
        strResult = "10";
    }
    else
    {
        strResult = "a 1 with " + intRounded.toLocaleString() + " zeros after it";
    }

    return strResult;
}

function formatLargeExponent(fltExponent_a)
{
	var strResult = "";
	
    if (fltExponent_a < 3)
    {
        strResult = "~" + Math.pow(10, fltExponent_a).toFixed(0) + " permutations";
    }
    else if (fltExponent_a < 6)
    {
        strResult = "~" + (Math.pow(10, fltExponent_a) / 1000).toFixed(1) + " thousand permutations";
    }
    else if (fltExponent_a < 9)
    {
        strResult = "~" + (Math.pow(10, fltExponent_a) / 1000000).toFixed(1) + " million permutations";
    }
    else if (fltExponent_a < 12)
    {
        strResult = "~" + (Math.pow(10, fltExponent_a) / 1000000000).toFixed(1) + " billion permutations";
    }
    else if (fltExponent_a < 15)
    {
        strResult = "~" + (Math.pow(10, fltExponent_a) / 1000000000000).toFixed(1) + " trillion permutations";
    }
    else if (fltExponent_a < 82)
    {
        strResult = "More than all atoms in the observable universe (10^" + fltExponent_a.toFixed(0) + " permutations)";
    }
    else if (fltExponent_a < 1000)
    {
        strResult = "Incomprehensibly massive (10^" + fltExponent_a.toFixed(0) + " permutations)";
    }
    else if (fltExponent_a < 1000000)
    {
        strResult = "Beyond all physical comparison (10^" + (fltExponent_a / 1000).toFixed(0) + " thousand permutations)";
    }
    else
    {
        strResult = "Astronomically secure (10^" + (fltExponent_a / 1000000).toFixed(1) + " million permutations)";
    }
	
	return strResult;
}

function setupButtons() 
{
    document.getElementById("clearBtn").addEventListener("click", function() 
    {
        g_arrRomData = null;
        g_strTextData = "";
        g_objEncodingResult = null;
		g_arrBinaryInputData = null; 
        
        var objRomDropZone = document.getElementById("romDropZone");
        objRomDropZone.classList.remove("has-file");
        objRomDropZone.innerHTML = "<div>Drop ROM FILE here to encode or verify quality<br>or click to browse</div>";
        
        var objZosciiDropZone = document.getElementById("zosciiDropZone");
        objZosciiDropZone.classList.remove("has-file");
        objZosciiDropZone.innerHTML = "<div>Drop BINARY or TEXT FILE here<br>or click to browse</div>";
        
        document.getElementById("textInput").value = "";
        document.getElementById("analysisContent").innerHTML = "<p class='text-muted'>Verify a ROM first to see quality analysis results.</p>";
        
        checkEncodeReady();
    });
    
	document.getElementById("verifyBtn").addEventListener("click", function() 
	{
		if (!g_arrRomData || (!g_strTextData && !g_arrBinaryInputData)) 
		{
			return;
		}
		
		this.disabled = true;
		this.textContent = "Verifying...";
        
        var strEncoding = document.getElementById("encodingSelect").value;
        var cbConverter = null;
		
		var intMaxSize;
		if (g_BITTAGE === 16)
		{
			intMaxSize = 65536;
		}
		else if (g_BITTAGE === 32)
		{
			intMaxSize = 4294967296;
		}
		
		var intSize = g_arrRomData.length;
		if (intSize > intMaxSize)
		{
			intSize = intMaxSize;
		}
		
		var arrMemoryBlocks = [
			{start: 0, size: intSize}
		];
        
        if (strEncoding === 'petscii')
        {
            cbConverter = petsciiToAscii;
        }
        else if (strEncoding === 'ebcdic')
        {
            cbConverter = ebcdicToAscii;
        }
       
		var varMixedInput = g_arrBinaryInputData || g_strTextData;
		var objResult = toZOSCII(g_arrRomData, varMixedInput, arrMemoryBlocks, cbConverter, 42);
        
		var strDisplayText;
		var intInputLength;
		if (g_arrBinaryInputData) 
		{
			strDisplayText = "Binary file data";
			intInputLength = g_arrBinaryInputData.length;
		} 
		else 
		{
			strDisplayText = g_strTextData;
			intInputLength = g_strTextData.length;
		}

		g_objEncodingResult = {
			success: true,
			addresses: objResult.addresses,
			originalText: strDisplayText,
			inputLength: intInputLength,
			encoding: strEncoding,
			addressCount: objResult.addresses.length,
			inputCounts: objResult.inputCounts,
			romCounts: objResult.romCounts
		};
        
        displayAnalysis(g_objEncodingResult);
        document.getElementById("analysis-tab").click();
        this.disabled = false;
        this.textContent = "Verify ROM";
    });
}

function setupDropZone(strSelector_a, cbOnFileHandler) 
{
    var objDropZone = document.querySelector(strSelector_a);
    
    objDropZone.addEventListener("dragover", function(objEvent_a) 
    {
        objEvent_a.preventDefault();
        this.classList.add("dragover");
    });
    
    objDropZone.addEventListener("dragleave", function(objEvent_a) 
    {
        objEvent_a.preventDefault();
        this.classList.remove("dragover");
    });
    
    objDropZone.addEventListener("drop", function(objEvent_a) 
    {
        objEvent_a.preventDefault();
        this.classList.remove("dragover");
        
        var arrFiles = objEvent_a.dataTransfer.files;
        if (arrFiles.length > 0) 
        {
            cbOnFileHandler(arrFiles[0]);
        }
    });
}

function setupDropZones() 
{
    // ROM file drop zone
    setupDropZone("#romDropZone", function(objFile_a) 
    {
        var objReader = new FileReader();
        objReader.onload = function(objEvent_a) 
        {
            g_arrRomData = new Uint8Array(objEvent_a.target.result);
            var objRomDropZone = document.getElementById("romDropZone");
            objRomDropZone.classList.add("has-file");
            objRomDropZone.innerHTML = "<div>ROM file loaded: " + objFile_a.name + " (" + objFile_a.size + " bytes)</div>";
            checkEncodeReady();
        };
        objReader.readAsArrayBuffer(objFile_a);
    });

    // ROM drop zone click handler
    document.getElementById("romDropZone").addEventListener("click", function() 
    {
        document.getElementById("romFileInput").click();
    });
    
    // ROM file input change handler
    document.getElementById("romFileInput").addEventListener("change", function() 
    {
        if (this.files.length > 0) 
        {
            var objFile = this.files[0];
            var objReader = new FileReader();
            objReader.onload = function(objEvent_a) 
            {
                g_arrRomData = new Uint8Array(objEvent_a.target.result);
                var objRomDropZone = document.getElementById("romDropZone");
                objRomDropZone.classList.add("has-file");
                objRomDropZone.innerHTML = "<div>ROM file loaded: " + objFile.name + " (" + objFile.size + " bytes)</div>";
                checkEncodeReady();
            };
            objReader.readAsArrayBuffer(objFile);
        }
    });
	
    // UNIFIED input file handler
    function handleInputFile(objFile_a) 
    {
        // Clear all previous data
        g_arrBinaryInputData = null;
        g_strTextData = "";
        
        // Always read as binary - let toZOSCII handle it
        var objReader = new FileReader();
        objReader.onload = function(objEvent_a) 
        {
            g_arrBinaryInputData = new Uint8Array(objEvent_a.target.result);
            document.getElementById("textInput").value = "File loaded: " + objFile_a.name + " (" + objFile_a.size + " bytes)";
            var objZosciiDropZone = document.getElementById("zosciiDropZone");
            objZosciiDropZone.classList.add("has-file");
            objZosciiDropZone.innerHTML = "<div>File loaded: " + objFile_a.name + " (" + objFile_a.size + " bytes)</div>";
            checkEncodeReady();
        };
        objReader.readAsArrayBuffer(objFile_a);
    }

    // Input zone drop handler
    setupDropZone("#zosciiDropZone", handleInputFile);
    
    // Input zone click handler  
    document.getElementById("zosciiDropZone").addEventListener("click", function() 
    {
        document.getElementById("textFileInput").click();
    });
    
    // File picker handler
    document.getElementById("textFileInput").addEventListener("change", function() 
    {
        if (this.files.length > 0) 
        {
            handleInputFile(this.files[0]);
        }
    });
    
    // Text typing handler
    document.getElementById("textInput").addEventListener("input", function() 
    {
        // Only allow typing if no file is loaded
        if (!g_arrBinaryInputData) 
        {
            g_strTextData = this.value;
            var objZosciiDropZone = document.getElementById("zosciiDropZone");
            if (g_strTextData) 
            {
                objZosciiDropZone.classList.add("has-file");
                objZosciiDropZone.innerHTML = "<div>Text entered (" + g_strTextData.length + " characters)</div>";
            } 
            else 
            {
                objZosciiDropZone.classList.remove("has-file");
                objZosciiDropZone.innerHTML = "<div>Drop BINARY or TEXT FILE here<br>or click to browse</div>";
            }
            checkEncodeReady();
        }
    });
}

function showTab(strTabName_a) 
{
	var intI;
	
    // Hide all tab panes
    var arrTabPanes = document.querySelectorAll('.tab-pane');
    for (intI = 0; intI < arrTabPanes.length; intI++) 
    {
        arrTabPanes[intI].classList.remove('active');
    }
    
    // Remove active class from all nav links
    var arrNavLinks = document.querySelectorAll('.nav-link');
    for (intI = 0; intI < arrNavLinks.length; intI++) 
    {
        arrNavLinks[intI].classList.remove('active');
    }
    
    // Show selected tab pane
    document.getElementById(strTabName_a).classList.add('active');
    
    // Add active class to selected nav link
    document.getElementById(strTabName_a + '-tab').classList.add('active');
}

function trackAddressUsage(intAddress, intPosition) 
{
    // Track this address usage
    if (!g_objLeakageTracker.addressUsage[intAddress]) 
	{
        g_objLeakageTracker.addressUsage[intAddress] = 0;
        g_objLeakageTracker.positionMap[intAddress] = [];
    }
    
    g_objLeakageTracker.addressUsage[intAddress]++;
    g_objLeakageTracker.positionMap[intAddress].push(intPosition);
    
    // Check for new leakage
    if (g_objLeakageTracker.addressUsage[intAddress] > 1) 
	{
        // LEAKAGE DETECTED!
        var arrPositions = g_objLeakageTracker.positionMap[intAddress];
        var intFrequency = arrPositions.length;
        
        g_objLeakageTracker.leakedPatterns.push({
            address: intAddress,
            frequency: intFrequency,
            positions: arrPositions.slice(), // copy array
            leakType: "FREQUENCY_PATTERN"
        });
        
        //console.log("LEAKAGE: Address 0x" + intAddress.toString(16).toUpperCase() + " reveals " + intFrequency + "-frequency pattern at positions [" + arrPositions.join(', ') + "]");
    }
}

// Cyborg ZOSCII v20250805
// (c) 2025 Cyborg Unicorn Pty Ltd.
// This software is released under MIT License.

// Function to convert string or binary data to ZOSCII address sequence
// arrBinaryData_a: Uint8Array containing the ROM/binary data  
// mixedInputData_a: String or Uint8Array containing the data to convert
// arrMemoryBlocks_a: array of {start: startAddress, size: blockSize} objects
// cbConverter_a: encoding conversion function (e.g., petsciiToAscii, ebcdicToAscii) or null
// intUnmappableChar_a: the native character code to be used if it cannot be mapped to ASCII
// Returns: {addresses: array, inputCounts: array, romCounts: array}

function toZOSCII(arrBinaryData_a, mixedInputData_a, arrMemoryBlocks_a, cbConverter_a, intUnmappableChar_a)
{
    var intStartTime = new Date().getTime();
	
    var intI;
    var intBlock;
    var intResultIndex = 0;
    var intResultCount = 0;
    var intDebugMissing = 0;
    
    var arrByteCounts = new Array(256);
    var arrByteAddresses = new Array(256);
    var arrOffsets = new Array(256);
    var arrInputCounts = new Array(256);
	var intAddress;
	var intByte;
	var intIndex;
	var objBlock;
    
    // Convert input to consistent format
    var arrInputData_a;
    var blnIsString = false;
    
    if (typeof mixedInputData_a === 'string') 
{
        // Handle string input - convert to UTF-8 bytes
        arrInputData_a = new TextEncoder().encode(mixedInputData_a);
        blnIsString = true;
    } else {
        // Handle Uint8Array input
        arrInputData_a = mixedInputData_a;
        blnIsString = false;
    }
    
    // Initialize counters
    for (intI = 0; intI < 256; intI++)
    {
        arrByteCounts[intI] = 0;
        arrInputCounts[intI] = 0;
    }
	
	clearLeakageTracker();
    
    // Pass 1: Count occurrences by iterating through blocks
    for (intBlock = 0; intBlock < arrMemoryBlocks_a.length; intBlock++)
    {
        objBlock = arrMemoryBlocks_a[intBlock];
        for (intAddress = objBlock.start; intAddress < (objBlock.start + objBlock.size); intAddress++)
        {
            intByte = arrBinaryData_a[intAddress];
            arrByteCounts[intByte]++;
        }
    }
    
    // Pass 2: Pre-allocate exact-sized arrays
    for (intI = 0; intI < 256; intI++)
    {
        arrByteAddresses[intI] = new Array(arrByteCounts[intI]);
        arrOffsets[intI] = 0;
    }
    
    // Pass 3: Populate arrays by iterating through blocks
    for (intBlock = 0; intBlock < arrMemoryBlocks_a.length; intBlock++)
    {
        objBlock = arrMemoryBlocks_a[intBlock];
        for (intAddress = objBlock.start; intAddress < (objBlock.start + objBlock.size); intAddress++)
        {
            intByte = arrBinaryData_a[intAddress];
            arrByteAddresses[intByte][arrOffsets[intByte]] = intAddress;
			arrOffsets[intByte]++;
        }
    }
    
    // Build result array with random addresses - pre-allocate and avoid push()
    for (intI = 0; intI < arrInputData_a.length; intI++)
    {
        intIndex = arrInputData_a[intI];  // Direct byte value
        
        // Apply encoding conversion if provided
        if (cbConverter_a)
        {
            intIndex = cbConverter_a(intIndex, intUnmappableChar_a);
        }
        
        if (intIndex >= 0 && intIndex < 256 && arrByteAddresses[intIndex] && arrByteAddresses[intIndex].length > 0)
        {
            intResultCount++;
        }
        else
        {
            intDebugMissing++;
            if (intDebugMissing <= 10)
            {
                var strHexByte = arrInputData_a[intI].toString(16).toUpperCase();
                if (strHexByte.length < 2) strHexByte = "0" + strHexByte;
                
                if (blnIsString) 
				{
                    console.log("Missing character: '" + String.fromCharCode(arrInputData_a[intI]) + "' (code " + arrInputData_a[intI] + "/0x" + strHexByte + " -> " + intIndex + ")");
                } 
				else 
				{
                    console.log("Missing byte: " + arrInputData_a[intI] + " (0x" + strHexByte + " -> " + intIndex + ")");
                }
            }
        }
    }

    if (blnIsString) 
	{
        console.log("Characters found in ROM: " + intResultCount);
        console.log("Characters missing from ROM: " + intDebugMissing);
    } 
	else 
	{
        console.log("Bytes found in ROM: " + intResultCount);
        console.log("Bytes missing from ROM: " + intDebugMissing);
    }

    var arrResult = new Array(intResultCount);

    for (intI = 0; intI < arrInputData_a.length; intI++)
    {
        intIndex = arrInputData_a[intI];  // Direct byte value
        
        // Apply encoding conversion if provided
        if (cbConverter_a)
        {
            intIndex = cbConverter_a(intIndex, intUnmappableChar_a);
        }

        if (intIndex >= 0 && intIndex < 256 && arrByteAddresses[intIndex] && arrByteAddresses[intIndex].length > 0)
        {
            arrInputCounts[intIndex]++;
            var intRandomPick = Math.floor(Math.random() * arrByteAddresses[intIndex].length);
            arrResult[intResultIndex] = arrByteAddresses[intIndex][intRandomPick];
			if (arrInputData_a.length <= 65535)
			{
				trackAddressUsage(arrByteAddresses[intIndex][intRandomPick], intResultIndex);
			}
			intResultIndex++;
        }
    }

    var intEndTime = new Date().getTime();
    var intElapsedMs = intEndTime - intStartTime;
    
    console.log("ZOSCII Performance:");
    console.log("- Binary size: " + arrBinaryData_a.length + " bytes");
    console.log("- Input length: " + arrInputData_a.length + (blnIsString ? " characters" : " bytes"));
    console.log("- Memory blocks: " + arrMemoryBlocks_a.length);
    console.log("- Execution time: " + intElapsedMs + "ms");
    console.log("- Output addresses: " + arrResult.length);
    
    return {
        addresses: arrResult,
        inputCounts: arrInputCounts,
		romCounts: arrByteCounts
    };
}

// Function to convert PETSCII character codes to ASCII character codes
// intPetsciiChar_a: PETSCII character code (0-255)
// intUnmappableChar_a: the native character code to be used if it cannot be mapped to ASCII
// Returns: ASCII character code or intUnmappableChar_a (suggested *) for unmappable characters
function petsciiToAscii(intPetsciiChar_a, intUnmappableChar_a)
{
    var arrPetsciiToAsciiMap = [
        // 0-31: Control characters
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a,
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a,
        
        // 32-63: Space, digits, punctuation (direct ASCII mapping)
        32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
        
        // 64-95: @A-Z[\]^_ (direct ASCII mapping)
        64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
        
        // 96-255: Everything else
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a,
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a,
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a,
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a,
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a,
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a,
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a,
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a,
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a,
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a
    ];
    
    return arrPetsciiToAsciiMap[intPetsciiChar_a];
}

// Function to convert EBCDIC character codes to ASCII character codes
// intEbcdicChar_a: EBCDIC character code (0-255)
// intUnmappableChar_a: the native character code to be used if it cannot be mapped to ASCII
// Returns: ASCII character code or intUnmappableChar_a (suggested) for unmappable characters
function ebcdicToAscii(intEbcdicChar_a, intUnmappableChar_a)
{
    var arrEbcdicToAsciiMap = [
        // 0-63: Control/special
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a,
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a,
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a,
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a,
        
        // 64-79: Space and some punctuation
        32, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, 46, 60, 40, 43, 124, // Space .....<(+|
        
        // 80-95: & and punctuation
        38, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, 33, 36, intUnmappableChar_a, 41, 59, intUnmappableChar_a, // &.........!$.).;.
        
        // 96-111: - and punctuation
        45, 47, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, 44, 37, 95, 62, 63, // -/........,%_>?
        
        // 112-127: More punctuation
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, 96, 58, 35, 64, 39, 61, 34, // .........`:#@'="
        
        // 128: Control
        intUnmappableChar_a,
        
        // 129-137: a-i
        97, 98, 99, 100, 101, 102, 103, 104, 105,
        
        // 138-144: Control/special
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a,
        
        // 145-153: j-r  
        106, 107, 108, 109, 110, 111, 112, 113, 114,
        
        // 154-161: Control/special
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a,
        
        // 162-169: s-z
        115, 116, 117, 118, 119, 120, 121, 122,
        
        // 170-192: Control/special
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a,
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a,
        
        // 193-201: A-I
        65, 66, 67, 68, 69, 70, 71, 72, 73,
        
        // 202-208: Control/special
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a,
        
        // 209-217: J-R
        74, 75, 76, 77, 78, 79, 80, 81, 82,
        
        // 218-225: Control/special
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a,
        
        // 226-233: S-Z
        83, 84, 85, 86, 87, 88, 89, 90,
        
        // 234-239: Control/special
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a,
        
        // 240-249: 0-9
        48, 49, 50, 51, 52, 53, 54, 55, 56, 57,
        
        // 250-255: Control/special
        intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a, intUnmappableChar_a
    ];
    
    return arrEbcdicToAsciiMap[intEbcdicChar_a];
}
	</script>
</body>
</html>