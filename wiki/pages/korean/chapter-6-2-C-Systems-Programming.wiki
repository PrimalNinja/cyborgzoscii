== Part B – C 시스템 프로그래밍 ==

'''고성능 구현 • 임베디드 시스템 애플리케이션 • 메모리 관리 전략 • 크로스 플랫폼 호환성'''

정보 분석가들이 중고 가게 Commodore 64에 패배한 500억 달러짜리 사이버 감시 인프라를 두고 눈물을 흘리는 모습은 ZOSCII가 단순한 보안 혁신 이상을 나타내는 이유를 완벽하게 보여줍니다—현대 시스템이 잊어버린 계산적 우아함으로의 회귀입니다.

인터넷 접속에서 "2020년 이전" 컴퓨터를 금지하려는 그랜트 장관의 공황 주도 법안은 불편한 진실을 드러냅니다: 제한된 리소스와 우아한 디자인을 가진 빈티지 컴퓨팅 시스템은 속도와 보안 모두에서 비대해진 현대 인프라를 능가할 수 있습니다. 1980년대 프로그래머들이 효율적이고 최소한의 코드를 작성하도록 강요한 동일한 제약이 ZOSCII의 주소 기반 접근 방식을 위한 완벽한 플랫폼을 만듭니다.

정부 감시 시스템을 디지털 신경 쇠약으로 보낸 CP/M 구현을 살펴보겠습니다.

=== CP/M: 계산적 순수성을 통한 보안 ===

ZOSCII의 CP/M 구현은 리소스 제약이 어떻게 우아한 솔루션을 강요하는지 보여줍니다. 현대 시스템이 암호화 라이브러리에 기가바이트의 메모리를 낭비하는 동안, 전체 ZOSCII 시스템은 1977년 Z80 기반 머신의 64KB 주소 공간 내에서 편안하게 실행됩니다.

=== ZENCODE: 스트리밍 인코더 ===

zencode 프로그램은 심각하게 메모리가 제한된 시스템에서도 ZOSCII를 실용적으로 만드는 3단계 최적화 전략을 보여줍니다:

'''1단계: ROM 분석'''
count_bytes() 함수는 전체 ROM을 한 번 스캔하여 각 바이트 값(0-255)에 대한 발생 횟수를 구축합니다. ROM을 통한 이 단일 패스는 모든 후속 작업의 기초를 설정합니다:

<code>
for (i = 0; i < actual_rom_size; i++) {
    byte_val = *rom_ptr & 0xFF;
    lookup_table[byte_val * 3]++;
    rom_ptr++;
}
</code>

조회 테이블 구조는 바이트 값당 컴팩트한 3워드 형식을 사용합니다: 발생 횟수, 블록 포인터 및 채우기 카운터. 이 1.5KB 테이블은 모든 바이트 값에 대한 할당 정보에 즉시 액세스할 수 있도록 합니다.

'''2단계: 메모리 할당'''
allocate_blocks() 함수는 정확한 메모리 요구 사항을 사전 계산하고 적절한 크기의 주소 목록을 할당합니다. 이것은 총 64KB RAM만 있는 시스템에서 불가능한 동적 메모리 할당을 제거합니다:

<code>
for (byte_val = 0; byte_val < 256; byte_val++) {
    occurrence_count = lookup_table[byte_val * 3];
    if (occurrence_count > 0) {
        lookup_table[byte_val * 3 + 1] = alloc_ptr;
        block_size = occurrence_count * 2;
        alloc_ptr += block_size;
    }
}
</code>

'''3단계: 주소 목록 채우기'''
populate_address_lists() 함수는 ROM을 두 번째로 통과하여 사전 할당된 주소 목록을 실제 ROM 위치로 채웁니다. 이 접근 방식은 각 ROM 바이트가 정확히 두 번 검사됨을 의미합니다—한 번은 카운팅을 위해, 한 번은 주소 기록을 위해—빈티지 시스템의 느린 디스크 I/O 특성에 최적화됩니다.

스트리밍 아키텍처는 1KB 청크로 입력 파일을 처리하여 시스템이 사용 가능한 RAM보다 큰 파일을 인코딩할 수 있도록 합니다. 48KB의 여유 메모리가 있는 CP/M 시스템은 어려움 없이 메가바이트 파일을 인코딩할 수 있습니다—전체 파일을 메모리에 로드해야 하는 암호화 접근 방식으로는 불가능한 일입니다.

=== ZDECODE: 우아한 단순함 ===

디코더 구현은 ZOSCII의 근본적인 장점을 드러냅니다: 디코딩에는 복잡한 데이터 구조나 다중 패스 알고리즘이 필요하지 않습니다. zdecode 프로그램은 이 우아함을 보여줍니다:

<code>
address_low = input_chunk[input_offset] & 0xFF;
address_high = input_chunk[input_offset + 1] & 0xFF;
rom_address = address_low | (address_high << 8);

decoded_byte = rom_start[rom_address];
</code>

네 줄의 코드가 전체 디코딩 작업을 수행합니다. 조회 테이블 없음, 수학적 계산 없음, 상태 관리 없음—단지 직접 메모리 액세스입니다. 이 단순함이 50달러짜리 Commodore 64가 수백만 달러짜리 정부 시스템보다 빠르게 보안 통신을 처리할 수 있게 한 것입니다.

스트리밍 디코더는 2KB 청크의 주소 쌍을 처리하여 1KB 청크의 디코딩된 바이트로 변환합니다. 메모리 사용량은 입력 파일 크기에 관계없이 일정하게 유지되며 처리 속도는 계산 복잡성이 아닌 디스크 I/O 속도에만 의존합니다.

=== ZSTRENGTH: 빈티지 하드웨어의 보안 분석 ===

zstrength 프로그램은 ROM 파일 및 입력 텍스트의 포괄적인 보안 분석을 수행하여 현대 감시 시스템이 깰 수 없는 조합적 강도를 계산합니다.

'''4단계: 입력 파일 분석'''
분석기는 스트리밍 방식으로 입력 파일을 읽어 전체 파일을 메모리에 로드하지 않고 문자 빈도 분포를 구축합니다:

<code>
while ((bytes_read = fread(input_chunk, 1, 1024, input_file)) > 0) {
    for (i = 0; i < bytes_read; i++) {
        byte_val = input_chunk[i] & 0xFF;
        input_counts[byte_val]++;
    }
}
</code>

'''5단계: 보안 계산'''
강도 계산은 8비트 프로세서에서 사용 가능한 정수 산술을 사용하여 정보 이론적 보안 원칙을 보여줍니다:

<code>
for (i = 0; i < 256; i++) {
    rom_count = lookup_table[i * 3];
    input_count = input_counts[i];
    
    if (rom_count > 0 && input_count > 0) {
        byte_log = log10_approx(rom_count);
        file_strength += input_count * byte_log / 100;
    }
}
</code>

log10_approx() 함수는 정수 연산만 사용하여 보안 분석에 충분한 정밀도를 제공합니다—부동 소수점 수학 유닛이 필요하지 않습니다. 이를 통해 하드웨어 수학 보조 프로세서가 없는 1970년대 프로세서에서 정확한 보안 계산이 가능합니다.

=== 제한된 시스템에서의 메모리 관리 ===

CP/M 구현은 현대 프로그래머들이 잊어버린 메모리 관리 기술을 보여줍니다. 총 64KB의 시스템 메모리만 있으면 모든 바이트가 중요합니다:

'''효율적인 메모리 레이아웃'''

프로그램은 신중하게 계획된 계층 구조로 메모리를 구성합니다:

*프로그램 코드: 완전한 ZOSCII 시스템을 위한 ~8KB
*조회 테이블: 바이트 발생 추적을 위한 1.5KB
*주소 목록: ROM 위치 저장을 위한 ~32KB
*ROM 데이터: 메모리 상단에 로드된 16KB
*I/O 버퍼: 파일 스트리밍을 위한 ~6KB
*여유 공간: 시스템 작업을 위한 나머지 메모리

이 레이아웃은 임의로 큰 입력 파일에 대한 스트리밍 기능을 유지하면서 최대 ROM 크기를 보장합니다.

'''스택 기반 버퍼 관리'''

입력 및 출력 작업은 신중한 포인터 관리와 함께 고정 크기 버퍼를 사용합니다:

<code>
char input_chunk[1024];
char output_buffer[2048];
</code>

버퍼 크기는 CP/M의 128바이트 섹터 크기에 최적화되면서 디스크 I/O 작업을 최소화하기에 충분한 버퍼링을 제공합니다. 2:1 출력 버퍼 비율은 동적 할당 없이 ZOSCII의 주소 확장을 수용합니다.

'''성능을 위한 포인터 산술'''

직접 포인터 조작은 함수 호출 오버헤드를 제거하고 느린 프로세서에서 최대 성능을 제공합니다:

<code>
rom_ptr = rom_start;
for (i = 0; i < actual_rom_size; i++) {
    byte_val = *rom_ptr & 0xFF;
    // 바이트 처리
    rom_ptr++;
}
</code>

이 접근 방식은 Z80 프로세서에서 인덱스된 배열 액세스에 비해 ~41%의 성능 향상을 달성합니다—ZOSCII 텍스트 출력을 ASCII 조회보다 빠르게 만드는 동일한 최적화입니다.

=== 크로스 플랫폼 호환성 원칙 ===

CP/M 구현은 공통 기능을 유지하면서 다양한 하드웨어 플랫폼에서 작동하는 패턴을 설정합니다:

'''바이트 순서 독립성'''

주소 저장은 일관되게 리틀 엔디안 형식을 사용합니다:

<code>
*write_ptr++ = i & 0xFF;          // 하위 바이트
*write_ptr = (i >> 8) & 0xFF;     // 상위 바이트
</code>

이 접근 방식은 파일 교환 중 바이트 스와핑 없이 8비트 CP/M 시스템과 현대 빅 엔디안 아키텍처 간의 호환성을 보장합니다.

'''고정 데이터 구조 크기'''

모든 데이터 구조는 컴파일러 종속 타입이 아닌 명시적 크기 지정을 사용합니다:

<code>
int lookup_table[768];  // 256 * 3 = 768 워드, 워드 크기에 관계없이
</code>

이것은 다양한 워드 길이를 가진 시스템과의 호환성을 유지하면서 다른 int 크기를 가진 플랫폼에서 일관된 동작을 보장합니다.

'''휴대용 파일 I/O'''

파일 작업은 모든 플랫폼에서 사용 가능한 표준 C 라이브러리 함수만 사용합니다:

<code>
bytes_read = fread(rom_start, 1, 16384, rom_file);
fwrite(output_buffer, 1, output_pos, output_file);
</code>

바이너리 모드 처리 및 오류 검사는 다른 줄 끝 규칙 및 파일 시스템 특성을 가진 플랫폼에서 일관된 동작을 제공합니다:

<code>
rom_file = fopen(filename, "rb");  // 바이너리 읽기 모드
if (!rom_file) {
    printf("Cannot open ROM file: %s\n", filename);
    return 0;
}

output_file = fopen(output_filename, "wb");  // 바이너리 쓰기 모드
if (!output_file) {
    printf("Cannot create output file: %s\n", output_filename);
    fclose(rom_file);
    return 0;
}
</code>

명시적 바이너리 모드 지정은 텍스트 및 바이너리 파일 처리를 구분하는 시스템에서 ZOSCII 주소 데이터를 손상시킬 텍스트 모드 변환을 방지합니다.

'''오류 처리 일관성'''

표준 오류 코드는 다른 운영 체제에서 일관된 동작을 제공합니다:

<code>
if (alloc_ptr >= rom_start) {
    printf("ERROR: Address tables overflow into ROM space!\n");
    printf("Tables need %d bytes, only %d available\n", 
           alloc_ptr - tpa_start, rom_start - tpa_start);
    exit(1);  // 표준 종료 코드
}
</code>

종료 코드 및 오류 메시지는 CP/M, MS-DOS, Unix 및 현대 시스템에서 동일하게 작동하는 규칙을 따라 자동화 스크립트 및 배치 처리에 대한 일관된 동작을 보장합니다.

'''엔디안 관리'''

CP/M 구현은 플랫폼 포트에서 일관되게 유지되는 엔디안 규칙을 설정합니다:

<code>
// 주소를 2바이트로 저장 (리틀 엔디안)
*write_ptr++ = i & 0xFF;      // 하위 바이트 먼저
*write_ptr = (i >> 8) & 0xFF; // 상위 바이트 나중에
</code>

이 리틀 엔디안 저장 형식은 컴파일러별 바이트 순서 가정에 의존하는 대신 명시적 바이트 조작을 통해 빅 엔디안 시스템에 액세스 가능하게 유지하면서 Z80 프로세서의 기본 바이트 순서와 일치합니다.

=== 감시 시스템 붕괴 ===

레트로 컴퓨팅에 대한 그랜트 장관의 공황으로 돌아가서, CP/M 구현은 현대 감시 인프라가 ZOSCII를 실행하는 빈티지 시스템에 대해 실패하는 이유를 정확히 보여줍니다.

'''계산 불일치'''

정부 감시 시스템은 인식 가능한 암호화 패턴을 포함하는 네트워크 트래픽을 분석할 것으로 예상합니다. 빈티지 시스템의 ZOSCII 통신을 만나면 다음을 찾습니다:

'''예상 패턴 인식:'''
*암호화 헤더 및 메타데이터
*알고리즘 식별자 (AES, RSA 서명)
*키 교환 핸드셰이크
*인증서 체인

'''실제 ZOSCII 트래픽:'''
*원시 바이너리 데이터 스트림
*암호화 식별자 없음
*메시지 간 수학적 관계 없음
*무작위 노이즈와 구별할 수 없는 주소 시퀀스

'''리소스 할당 실패'''

현대 감시 인프라는 현대 위협을 위해 설계되었습니다. AES-256을 깨기 위해 최적화된 500억 달러 시스템은 직접 ROM 주소 지정을 사용하는 CP/M 시스템에 대해 제로 이점을 제공합니다.

'''감시 시스템 능력:'''
*양자 저항 암호화 분석기
*기계 학습 패턴 인식
*인수분해를 위한 분산 컴퓨팅 클러스터
*고급 트래픽 상관 알고리즘

'''ZOSCII 분석에 필요:'''
*특정 ROM 파일에 대한 액세스 (물리적 소유)
*주소-문자 매핑 이해 (ROM 분석)
*계산 능력 이점 불가능

"공격 표면"이 해석을 위해 외부 컨텍스트 파일이 필요한 무의미한 주소 조회로 구성될 때 정부의 값비싼 인프라는 무관해집니다.

=== 우아한 아이러니 ===

그러한 공황을 일으킨 CP/M ZOSCII 구현은 현대 보안 시스템이 잊어버린 것을 정확히 나타냅니다: 복잡성을 통한 보안이 아닌 단순함을 통한 우아함.

'''현대 보안 철학:''' 더 정교한 수학이 더 강력한 보호를 만듭니다
'''CP/M ZOSCII 철학:''' 수학을 제거하여 공격 벡터를 제거합니다

'''결과:''' 6KB 코드를 실행하는 1977년 컴퓨터는 수십억 달러짜리 현대 인프라보다 더 나은 통신 보안을 제공합니다. 왜냐하면 악용 가능한 복잡성을 포함하기에는 너무 간단한 원칙으로 작동하기 때문입니다.

우리 오프닝 풍자에서 제안된 레트로 컴퓨터 금지는 실제로 빈티지 하드웨어를 중단하는 것이 아니었습니다—새로운 것이 항상 더 나은 것은 아니며 가장 안전한 시스템이 보안 전문가가 가장 이해하지 못하는 시스템일 수 있다는 공개적 인식을 방지하는 것이었습니다.
