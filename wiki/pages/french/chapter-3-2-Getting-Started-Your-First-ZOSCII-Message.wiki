== Partie B – Débuter : Votre Premier Message ZOSCII ==

L'arrestation de Harold Flourworth pour possession de « codes de lancement nucléaire classifiés » illustre parfaitement pourquoi ZOSCII est si révolutionnaire—et pourquoi les autorités traditionnelles passent complètement à côté du sujet. Lorsque les enquêteurs ont finalement décodé le fichier ZOSCII de Harold (après des semaines d'analyse classifiée), ils ont découvert la recette secrète de biscuits aux pépites de chocolat de sa grand-mère. La « séquence de lancement » qui terrifiait les experts en sécurité nationale était en réalité : « Préchauffez le four à 180°C. Fouettez le beurre et le sucre jusqu'à obtenir une texture mousseuse... »

Ce délicieux cas d'erreur d'identité démontre le génie fondamental de ZOSCII : sans la clé ROM, toute séquence d'adresses peut contenir n'importe quoi, des secrets d'État aux instructions de pâtisserie. La recette de biscuits de Harold ressemblait en tout point à des codes nucléaires parce que, mathématiquement, ils SONT identiques—juste des nombres sans signification sans contexte.

Recréons le processus d'encodage « dangereux » de Harold et voyons comme il est facile de créer vos propres « armes de déliciosité massive ».

=== L'Implémentation JavaScript en 6 Lignes ===

La beauté de ZOSCII réside dans sa simplicité. Alors que les bibliothèques cryptographiques nécessitent des milliers de lignes de code complexe, le système ZOSCII complet peut être implémenté en seulement six lignes de JavaScript :

<code>
// CyborgZOSCII v20250817 - Le Système Complet
rom = "ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890: ,.ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890: ,.ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890: ,.";
encode = (r,m) => [...m].map(c => [...r].map((b,i)=>b==c?i:[]).flat().sort(()=>Math.random()-.5)[0]);
decode = (r,a) => a.map(a => r[a]).join('');
e = encode(rom, "HELLO");
api.print(e);
api.print(decode(rom,e));
</code>

C'est tout. Six lignes. Pas de bibliothèques cryptographiques, pas d'opérations mathématiques complexes, pas de fonctions de dérivation de clés. Juste une simple recherche et génération d'adresses.

Détaillons ce que fait chaque ligne :

*'''Ligne 1 :''' Crée notre ROM (dans ce cas, un alphabet simple répété, n'utilisez pas cet exemple simplifié en environnement de production)
*'''Ligne 2 :''' La fonction encode - trouve toutes les positions où chaque caractère apparaît dans la ROM, puis en sélectionne une au hasard
*'''Ligne 3 :''' La fonction decode - recherche quel caractère est stocké à chaque adresse
*'''Lignes 4-6 :''' Exemple d'utilisation - encoder "HELLO", afficher les adresses, décoder et afficher le résultat

La fonction encode effectue la magie fondamentale de ZOSCII :
*<code>[...m]</code> divise le message en caractères individuels
*<code>[...r].map((b,i)=>b==c?i:[])</code> trouve toutes les positions ROM contenant chaque caractère
*<code>.flat()</code> combine les résultats en un seul tableau d'adresses possibles
*<code>.sort(()=>Math.random()-.5)[0]</code> sélectionne aléatoirement une adresse

Ne vous inquiétez pas si ce très petit programme JavaScript est trop complexe, des versions plus simples seront présentées plus tard - mais c'est juste pour montrer à quel point l'algorithme est petit et élégant en JavaScript.

Cette sélection aléatoire est ce qui a donné à la recette de biscuits de Harold les mêmes propriétés statistiques que les codes de lancement nucléaire—chaque caractère pouvait être encodé en utilisant n'importe laquelle des multiples adresses disponibles.

=== Exécuter des Exemples sur CyborgShell.com ===

Pour voir ZOSCII en action immédiatement, visitez [https://cyborgshell.com|cyborgshell.com] et collez l'implémentation de six lignes directement dans la ligne de commande :

<code>run</code>

Vous verrez une sortie similaire à :

<code>
[7, 43, 28, 28, 41]
HELLO
</code>

La première ligne montre la séquence d'adresses—cinq nombres qui représentent où chaque lettre de "HELLO" peut être trouvée dans la ROM. La seconde ligne montre le résultat décodé.

Exécutez le même code à nouveau :

<code>run</code>

<code>
[15, 8, 54, 2, 67]
HELLO
</code>

Remarquez que les adresses sont complètement différentes, mais le message décodé est identique. Cet encodage non déterministe est ce qui a fait ressembler la recette de biscuits de Harold à du matériel classifié—la même recette générerait des motifs d'adresses différents à chaque fois qu'elle était encodée.

Essayez d'encoder différents messages :

<code>
e = encode(rom, "CLASSIFIED");
api.print(e);
api.print(decode(rom,e));
</code>

Ou la fameuse ligne d'ouverture de Harold :

<code>
e = encode(rom, "PREHEAT OVEN TO 180C");
api.print(e);
api.print(decode(rom,e));
</code>

Chaque fois que vous exécutez ceci, vous obtiendrez des adresses différentes mais le même texte décodé. C'est ce qui a tellement embrouillé les enquêteurs—les « codes nucléaires » de Harold étaient statistiquement indiscernables de véritables communications classifiées.

=== Comprendre les Fichiers ROM et l'Entropie ===

Le cas de Harold devient encore plus intéressant lorsque nous examinons la qualité de la ROM. Les enquêteurs supposaient que des « codes nucléaires » de haute qualité nécessiteraient des clés d'encodage sophistiquées. En réalité, Harold a utilisé une photo JPEG de sa grand-mère comme ROM—et elle a fourni une sécurité astronomique.

'''Bases de l'Entropie ROM :'''

Une bonne ROM ZOSCII doit contenir diverses valeurs d'octets avec de multiples occurrences de chaque caractère que vous voulez encoder. La photo de la grand-mère de Harold (JPEG de 64KB) contenait :

*Lettre 'A' : 847 occurrences à différentes positions
*Lettre 'B' : 923 occurrences
*Lettre 'C' : 756 occurrences
*Caractère espace : 1 200+ occurrences
*Chiffres 0-9 : 400+ occurrences chacun

Cette diversité a donné à la recette de biscuits de Harold approximativement 10^156 encodages possibles—la rendant plus sécurisée que les systèmes de chiffrement de niveau militaire que les enquêteurs supposaient qu'elle devait être.

'''Tester la Qualité de la ROM :'''

Vous pouvez évaluer la pertinence de n'importe quel fichier comme ROM ZOSCII en utilisant ce test simple :

<code>
function testROM(romData) {
    let counts = new Array(256).fill(0);
    for(let i = 0; i < romData.length; i++) {
        counts[romData[i]]++;
    }
    
    // Vérifier la couverture pour les caractères ASCII courants
    let goodChars = 0;
    for(let i = 32; i <= 126; i++) { // ASCII imprimable
        if(counts[i] > 0) goodChars++;
    }
    
    api.print(`La ROM couvre ${goodChars}/95 caractères imprimables`);
    api.print(`Occurrences moyennes par caractère : ${romData.length/95}`);
}
</code>

La photo de la grand-mère de Harold a obtenu un score de couverture de 94/95 caractères avec une moyenne de 680 occurrences par caractère—expliquant pourquoi sa recette de biscuits a atteint des cotes de sécurité de niveau nucléaire.

=== Votre Premier Cycle Encode/Decode ===

Recréons le processus de Harold étape par étape, en utilisant une ROM et un message plus réalistes :

'''Étape 1 : Choisissez Votre ROM'''
Pour cet exemple, nous utiliserons une simple chaîne de texte comme ROM (en pratique, vous utiliseriez un fichier binaire) :

<code>
rom = `THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG. PACK MY BOX WITH FIVE DOZEN LIQUOR JUGS. AMAZINGLY FEW DISCOTHEQUES PROVIDE JUKEBOXES. HOW VEXINGLY QUICK DAFT ZEBRAS JUMP! JACKDAWS LOVE MY BIG SPHINX OF QUARTZ. THE FIVE BOXING WIZARDS JUMP QUICKLY.`;
</code>

'''Étape 2 : Encodez Votre Message'''

<code>
message = "GRANDMA BISCUIT RECIPE: CREAM BUTTER AND SUGAR";
encoded = encode(rom, message);
api.print("Adresses encodées :");
api.print(encoded);
</code>

'''Étape 3 : Décodez pour Vérifier'''

<code>
decoded = decode(rom, encoded);
api.print("Message décodé :");
api.print(decoded);
</code>

'''Étape 4 : Démontrez les Propriétés Non Déterministes'''

<code>
// Encoder le même message plusieurs fois
for(let i = 0; i < 3; i++) {
    let addresses = encode(rom, message);
    api.print(`Encodage ${i+1} :`);
    api.print(addresses);
}
</code>

Chaque encodage produit des adresses différentes mais des résultats décodés identiques—tout comme la recette de biscuits de Harold que les enquêteurs ne pouvaient pas distinguer des protocoles nucléaires.

'''Comprendre la Sécurité :'''

La sécurité provient du nombre astronomique de façons dont le même message peut être encodé. Avec notre exemple de ROM contenant de multiples instances de chaque lettre :

*'G' : apparaît 8 fois à différentes positions
*'R' : apparaît 15 fois
*'A' : apparaît 12 fois
*Et ainsi de suite...

La recette de biscuits de 45 caractères de Harold avait approximativement 10^89 encodages possibles en utilisant la ROM de la photo de sa grand-mère—plus de combinaisons qu'il n'y a d'atomes dans l'univers observable.

=== Le Défi Harold Crumpet ===

Essayez cette expérience vous-même :

#Créez deux messages : un qui semble « dangereux » et un qui est complètement innocent
#Encodez les deux en utilisant la même ROM
#Comparez les séquences d'adresses résultantes

<code>
dangerous = "LAUNCH SEQUENCE ALPHA";
innocent = "I REALLY LOVE CHOCOLATE CHIP BISCUITS";

api.print("Adresses du message dangereux :");
api.print(encode(rom, dangerous));
api.print("Adresses du message innocent :");
api.print(encode(rom, innocent));
</code>

Vous découvrirez ce que les enquêteurs de Harold ont appris à leurs dépens : les deux messages produisent des séquences d'adresses statistiquement identiques. Sans la ROM, il n'y a aucun moyen de déterminer quel message est lequel, ou même qu'il s'agit de messages.

Les adresses pourraient tout aussi facilement décoder en :
*Poésie (« ROSES ARE RED VIOLETS ARE BLUE »)
*Listes de courses (« MILK BREAD EGGS BUTTER CHEESE »)
*Paroles de chansons (« HAPPY BIRTHDAY TO YOU »)
*Non-sens complet (« XQZPRF GLRMPH BWKTNS »)

C'est la déniabilité parfaite en action—la même technologie qui a fait ressembler Harold à un terroriste rend également impossible de prouver ce que contiennent réellement les communications de n'importe qui.

Le cas de Harold démontre parfaitement pourquoi ZOSCII représente un changement de paradigme du chiffrement vers la pure théorie de l'information. La cryptographie traditionnelle essaie de rendre les données difficiles à déchiffrer. ZOSCII élimine entièrement le concept de déchiffrement—sans la ROM, les données n'existent tout simplement pas sous une forme significative.

La preuve « irréfutable » des enquêteurs était en fait la preuve de la sécurité parfaite de ZOSCII : ils pouvaient faire dire aux adresses de Harold tout ce qu'ils voulaient qu'elles disent.
